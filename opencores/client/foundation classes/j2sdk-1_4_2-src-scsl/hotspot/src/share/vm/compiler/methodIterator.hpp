#ifdef USE_PRAGMA_IDENT_HDR
#pragma ident "@(#)methodIterator.hpp	1.93 03/01/23 12:01:30 JVM"
#endif
/*
 * Copyright 2003 Sun Microsystems, Inc.  All rights reserved.
 * SUN PROPRIETARY/CONFIDENTIAL.  Use is subject to license terms.
 */

// The following classes build a framework for iteration over method bytecodes:
//
// MethodIntervals      : represents an interval of byte codes
// MethodIntervalFactory: creates MethodIntervals
// MethodIterator       : iterates over a MethodInterval and dispatches to MethodClosure
// MethodClosure        : provides virtual functions for the different bytecode classes


//-----------------------------------------------------------------------------
// A MethodInterval represents an interval of byte codes
class MethodInterval: public ResourceObj {
 protected:
  MethodInterval*  _parent;	                 // enclosing interval (NULL if top-level)
  methodHandle     _method;                      // method to which the bytecodes belong
  int              _begin_bci;                   // index of first bytecode of sequence
  int              _end_bci;                     // index of first bytecode after sequence

  void initialize(methodHandle method, MethodInterval* parent, int begin_bci, int end_bci);
  void set_end_bci(int bci) { _end_bci = bci; }

  friend class MethodIntervalFactory;

 public:
   // Construction
  MethodInterval(methodHandle method, MethodInterval* parent);
  MethodInterval(methodHandle method, MethodInterval* parent, int begin_bci, int end_bci = -1);

  // Testing
  bool             contains(int bci) const       { return begin_bci() <= bci && bci < end_bci(); }

  // Accessors
  MethodInterval*  parent() const                { return _parent;    }
  methodHandle     method_handle() const         { return _method;    }
  int              begin_bci() const             { return _begin_bci; }
  int              end_bci() const               { return _end_bci;   }
};


//-----------------------------------------------------------------------------
// MethodIntervalFactory abstraction
class AbstractMethodIntervalFactory: public StackObj {
 public:
  virtual MethodInterval* new_MethodInterval(methodHandle method, MethodInterval* parent) = 0;
  virtual MethodInterval* new_MethodInterval(methodHandle method, MethodInterval* parent, int begin_bci, int end_bci = -1) = 0;
};


//-----------------------------------------------------------------------------
// Default factory
class MethodIntervalFactory: public AbstractMethodIntervalFactory {
 public:
  MethodInterval* new_MethodInterval(methodHandle method, MethodInterval* parent);
  MethodInterval* new_MethodInterval(methodHandle method, MethodInterval* parent, int begin_bci, int end_bci = -1);
};


class MethodIterator;

//-----------------------------------------------------------------------------
// A MethodClosure defines methods for each class of bytecodes (e.g. iload).
// The MethodIterator dispatches to these methods.
class MethodClosure: public ResourceObj {
 private:
  methodHandle _method;
  int       _bci;
  bool      _paired_instruction;
  bool      _exception_thrown;

  void      set_method(methodHandle method)                          { _method = method; }    
  void      set_bci(int bci)                                         { _bci = bci; }

  friend class MethodIterator;

 protected:
  // Accessors
  methodHandle method_handle() const                                 { return _method; }
  int          bci() const                                           { return _bci; } // bytecode bci of the active instruction
  
  virtual MethodIterator* iterator() const                           { return NULL; }   
    
 public:
  MethodClosure();
  // a thrown exception does not unwind the stack, but just sets the exception flag.
  // exception handling must be done manually.
  void set_exception_thrown(bool f)         { _exception_thrown = f;    }
  bool is_exception_thrown()          const { return _exception_thrown; }

  // Notifies the closure that the active instruction is first part of a paired instruction.
  // Called when a quick bytecode, generated by interpreter is encountered.
  // Quick bytecodes are split into two standard bytecodes. 'set_is_paired_instruction' is
  // called by the iterator.
  void set_is_paired_instruction()                                   { _paired_instruction = true; }
  bool is_paired_instruction() const                                 { return _paired_instruction; }
  void reset_is_paired_instruction()                                 { _paired_instruction = false; }

  virtual bool visit_this_bci() const                                { return true; }

 public:
  virtual bool isMethodStructureClosure() const                      { return false; }
  virtual bool isCodeGenClosure()         const                      { return false; }
  virtual void bytecode_prolog (Bytecodes::Code code) {}	     // called before each bytecode
  virtual void bytecode_default() {}	                             // default method called for each byte code
  virtual void bytecode_epilog () {}	                             // called after each bytecode

  // Loads & stores
  virtual void push_int   (jint    value)	                     { bytecode_default(); }
  virtual void push_long  (jlong   value)	                     { bytecode_default(); }
  virtual void push_float (jfloat  value)	                     { bytecode_default(); }
  virtual void push_double(jdouble value)	                     { bytecode_default(); }
  virtual void push_object(oop     value)                            { bytecode_default(); }
  virtual void push_unresolved_string_at(int i)                      { bytecode_default(); }

  virtual void load_local_int   (int index)	                     { bytecode_default(); }
  virtual void load_local_long  (int index)	                     { bytecode_default(); }
  virtual void load_local_float (int index)	                     { bytecode_default(); }
  virtual void load_local_double(int index)	                     { bytecode_default(); }
  virtual void load_local_object(int index)	                     { bytecode_default(); }

  virtual void store_local_int   (int index)	                     { bytecode_default(); }
  virtual void store_local_long  (int index)	                     { bytecode_default(); }
  virtual void store_local_float (int index)	                     { bytecode_default(); }
  virtual void store_local_double(int index)	                     { bytecode_default(); }
  virtual void store_local_object(int index)	                     { bytecode_default(); }

  virtual void increment_local_int(int index, jint offset)	     { bytecode_default(); }

  // Array operations
  virtual void array_length()	                                     { bytecode_default(); }

  virtual void load_array_byte()	                             { bytecode_default(); }
  virtual void load_array_char()	                             { bytecode_default(); }
  virtual void load_array_short()	                             { bytecode_default(); }
  virtual void load_array_int()                                      { bytecode_default(); }
  virtual void load_array_long()	                             { bytecode_default(); }
  virtual void load_array_float()	                             { bytecode_default(); }
  virtual void load_array_double()	                             { bytecode_default(); }
  virtual void load_array_object()	                             { bytecode_default(); }
  
  virtual void store_array_byte()	                             { bytecode_default(); }
  virtual void store_array_char()	                             { bytecode_default(); }
  virtual void store_array_short()	                             { bytecode_default(); }
  virtual void store_array_int()	                             { bytecode_default(); }
  virtual void store_array_long()	                             { bytecode_default(); }
  virtual void store_array_float()	                             { bytecode_default(); }
  virtual void store_array_double()	                             { bytecode_default(); }
  virtual void store_array_object()	                             { bytecode_default(); }

  // Stack operations
  virtual void nop()	                                             { bytecode_default(); }
  virtual void pop()	                                             { bytecode_default(); }
  virtual void pop2()	                                             { bytecode_default(); }
  virtual void dup()	                                             { bytecode_default(); }
  virtual void dup2()	                                             { bytecode_default(); }

  virtual void dup_x1()                                              { bytecode_default(); }
  virtual void dup2_x1()	                                     { bytecode_default(); }
  virtual void dup_x2()                                              { bytecode_default(); }
  virtual void dup2_x2()	                                     { bytecode_default(); }
  virtual void swap()	                                             { bytecode_default(); }

  // Unary arithmetic operations
  virtual void neg_int()	                                     { bytecode_default(); }
  virtual void neg_long()	                                     { bytecode_default(); }
  virtual void neg_float()	                                     { bytecode_default(); }
  virtual void neg_double()	                                     { bytecode_default(); }

  // Binary arithmetic operations
  enum arithmetic_op { add, sub, mul, div, rem, shr };
  virtual void arithmetic_int   (arithmetic_op op)	             { bytecode_default(); }
  virtual void arithmetic_long  (arithmetic_op op)	             { bytecode_default(); }
  virtual void arithmetic_float (arithmetic_op op)	             { bytecode_default(); }
  virtual void arithmetic_double(arithmetic_op op)	             { bytecode_default(); }

  // Binary logical operations
  enum logical_op { _shl, _ushr, _and, _or, _xor };
  virtual void logical_int (logical_op op)	                     { bytecode_default(); }
  virtual void logical_long(logical_op op)	                     { bytecode_default(); }

  // Conversion operations
  virtual void int_2_long()	                                     { bytecode_default(); }
  virtual void int_2_float()	                                     { bytecode_default(); }
  virtual void int_2_double()	                                     { bytecode_default(); }

  virtual void long_2_int()	                                     { bytecode_default(); }
  virtual void long_2_float()                                        { bytecode_default(); }
  virtual void long_2_double()                                       { bytecode_default(); }

  virtual void float_2_int()	                                     { bytecode_default(); }
  virtual void float_2_long()                                        { bytecode_default(); }
  virtual void float_2_double()                                      { bytecode_default(); }

  virtual void double_2_int()	                                     { bytecode_default(); }
  virtual void double_2_long()                                       { bytecode_default(); }
  virtual void double_2_float()                                      { bytecode_default(); }

  virtual void int_2_byte()	                                     { bytecode_default(); }
  virtual void int_2_char()	                                     { bytecode_default(); }
  virtual void int_2_short()	                                     { bytecode_default(); }

  // Control transfer operations
  enum cond_op {
    null, nonnull, eq, ne, lt, le, gt, ge
  };

  virtual void branch_if     (cond_op cond, int dest)	             { bytecode_default(); }
  virtual void branch_if_int (cond_op cond, int dest)	             { branch_if(cond, dest); } // int on stack
  virtual void branch_if_oop (cond_op cond, int dest)	             { branch_if(cond, dest); } // oop on stack
  virtual void branch_if_icmp(cond_op cond, int dest)	             { bytecode_default(); }
  virtual void branch_if_acmp(cond_op cond, int dest)	             { bytecode_default(); }

  virtual void long_cmp()	                                     { bytecode_default(); }
  virtual void float_cmpl()	                                     { bytecode_default(); }
  virtual void float_cmpg()	                                     { bytecode_default(); }
  virtual void double_cmpl()	                                     { bytecode_default(); }
  virtual void double_cmpg()	                                     { bytecode_default(); }

  virtual void branch(int dest)                                      { bytecode_default(); }
  virtual void jsr(int dest)	                                     { bytecode_default(); }
  virtual void ret(int index)	                                     { bytecode_default(); }

  virtual void return_int()	                                     { bytecode_default(); }
  virtual void return_long()	                                     { bytecode_default(); }
  virtual void return_float()                                        { bytecode_default(); }
  virtual void return_double()                                       { bytecode_default(); }
  virtual void return_object()                                       { bytecode_default(); }
  virtual void return_void()                                         { bytecode_default(); }

  virtual void table_switch (jint lo, jint hi, jint dest[], int default_dest)   { bytecode_default(); }
  virtual void lookup_switch(int len, jint key[], jint dest[], int default_dest) { bytecode_default(); }

  // get/set for dynamic class loading
  virtual void get_field_by_index (int klass_index, symbolOop field) { bytecode_default(); }
  virtual void put_field_by_index (int klass_index, symbolOop field) { bytecode_default(); }

  // Fast versions of getfield/putfield (used if the interpreter rewrote the bytecodes)
  virtual void get_field(BasicType field_type, int field_offset)     { bytecode_default(); }
  virtual void put_field(BasicType field_type, int field_offset)     { bytecode_default(); }
    
  // For dynamic initialization and loading
  virtual void get_static_by_index (int index)                       { bytecode_default(); }
  virtual void put_static_by_index (int index)                       { bytecode_default(); }

  // Method invocation
  virtual void invoke_interface_by_index     (int intfc_index, symbolHandle name, symbolHandle signature, int nofArgs) { bytecode_default(); }
  virtual void invoke_nonvirtual_by_index    (int klass_index, symbolHandle name, symbolHandle signature) { bytecode_default(); }
  virtual void invoke_static_by_index        (int klass_index, symbolHandle name, symbolHandle signature) { bytecode_default(); }
  virtual void invoke_virtual_klass_by_index (int klass_index, symbolHandle name, symbolHandle signature) { bytecode_default(); }

  // Exception handling
  virtual void throw_exception()                                     { bytecode_default(); }

  // Object and array allocation
  virtual void new_object_by_index(int klass_index)                  { bytecode_default(); }
  virtual void new_basic_array (int type)	                     { bytecode_default(); }
  virtual void new_object_array_by_index (int klass_index) 	     { bytecode_default(); }
  virtual void new_multi_array_by_index  (int klass_index, int nof_dims) { bytecode_default(); }


  virtual void check_cast_by_index (int klass_index)                 { bytecode_default(); }
  virtual void instance_of_by_index(int klass_index)                 { bytecode_default(); }

  // Monitors
  virtual void monitor_enter()                                       { bytecode_default(); }
  virtual void monitor_exit()                                        { bytecode_default(); }

  // fast instructions
  virtual void fast_iaccess_0(int field_offset)                      { bytecode_default(); }
  virtual void fast_aaccess_0(int field_offset)                      { bytecode_default(); }

  // Debugging
  virtual void unknown_bytecode()                                    = 0;
};


//-----------------------------------------------------------------------------
// The MethodIterator iterates over the byte code structures of a methodOop
// and dispatches calls to the provided MethodClosure. Usage:
// 
//   MethodIterator(method, &SomeMethodClosure);
//
// Note that an MethodIterator is conceptually iterating over "abstract byte codes".
// The Java byte codes can be categorized into groups which correspond to abstract
// instructions that generalize the JVM's instruction set. For example bipush and
// sipush both push an integer onto the stack. The distinction between them in the
// JVM is an optimization. Thus, both of these can be categorized as push_int instructions. 
// Instructions like push_int are herein called abstract byte codes.
//
// The MethodIterator maps the concrete byte codes in a MethodInterval into abstract byte codes;
// for every abstract byte code, it invokes a corrresponding method of a MethodClosure, which can
// perform some arbitrary action in response.

class MethodIterator: public ResourceObj {
 private:
  static MethodIntervalFactory _default_factory; // default factory
  static AbstractMethodIntervalFactory* _factory;// used to build nodes
  
  methodHandle    _method;                       // the method to which the bytecodes belong
  MethodInterval* _interval;                     // the interval to which the bytecodes belong
  
  BytecodeStream* _stream;                       // underlying bytecode iterator stream

  address         _this_pc;                      // start of current byte code
  address         _next_pc;                      // current decoding position
  
 public:
  // Helper functions
  //%note runtime_2
  // Note: The functions below should use the funtions in bytes_<arch>.hpp since
  //       they are tuned for efficiency. FIX THIS!
  void            align()                        { _next_pc = (address)round_to((intptr_t)_next_pc, sizeof(jint)); }  
  
  int             get_byte()                     { return *(jbyte*) _next_pc++; }  // signed  
  short           get_short()                    { short i=Bytes::get_Java_u2(_next_pc); _next_pc+=2; return i; }
  int             get_int()                      { int i=Bytes::get_Java_u4(_next_pc); _next_pc+=4; return i; }                                                   

  int             get_index()                    { return *(address)_next_pc++; }
  int             get_big_index()                { int i=Bytes::get_Java_u2(_next_pc); _next_pc+=2; return i; }
  int             get_index_special()            { return (_stream->is_wide()) ? get_big_index() : get_index(); }    
  int             get_dest()                     { int i = bci(); return i + get_short(); }
  int             get_far_dest()                 { int i = bci(); return i + get_int(); }

  int             get_fast_int()                 { int i = *(jint*)_next_pc; _next_pc += sizeof(jint); return i; }
  int             get_fast_dest()                { int i = bci(); return i + get_fast_int(); }
  int             get_fast_index()               { int i = Bytes::get_native_u2(_next_pc); _next_pc += 2; return i; }
  
  bool            is_wide() const                { return _stream->is_wide(); }
  bool            is_active_breakpoint() const   { return _stream->is_active_breakpoint(); }

  virtual void    identify_code(MethodClosure* blk, Bytecodes::Code code);
  virtual void    dispatch(MethodClosure* blk, Bytecodes::Code code);  
  void            push_constant(MethodClosure* blk, int i);

  // Subnode creation
  static AbstractMethodIntervalFactory* factory()          { return _factory; }
  static AbstractMethodIntervalFactory* default_factory()  { return (AbstractMethodIntervalFactory*)&_default_factory; }

  // Creation
  MethodIterator(methodHandle method,      AbstractMethodIntervalFactory* factory = &_default_factory);
  MethodIterator(MethodInterval* interval, AbstractMethodIntervalFactory* factory = &_default_factory);

  // Attributes
  methodHandle    method_handle() const          { return _method; }
  MethodInterval* interval() const               { return _interval; }

  address         bcp() const                    { return _this_pc; }
  address         next_bcp() const               { return _stream->next_bcp(); }
  
  int             bci()      const               { return _stream->bci(); }
  int	          next_bci() const               { return _stream->next_bci(); }

  Bytecodes::Code bytecode() const               { return _stream->code(); }  
  Bytecodes::Code next_bytecode() const          { return Bytecodes::Code(*next_bcp()); }

  // returns true if the bytecode is the last in code
  bool	          is_last_bytecode() const       { return _stream->is_last_bytecode(); }

  // Change itereation flow
  virtual Bytecodes::Code get_next_bytecode();
  void            set_next_bci(int bci)          { _stream->set_next_bci(bci); }
  
  // Iteration
  void            iterate(MethodClosure* blk);  
};



//-----------------------------------------------------------------------------
// A lightweight streaming iterator over method bytecodes.
// The abstraction never the bytecodes: wide, go_native, fast_xxx_tables.
//
// Usage: 
//   MethodBCStream i(methodHandle);
//   Bytecodes::Code bytecode;
//   while( (bytecode = i.next()) != EOBC ) { ... }
// 
// For bytecodes with trailing displacements, after the "i.next()" is
// executed the target bytecode address can be obtained with
// "i.get_dest()".  After table bytecodes, bytecode target addresses and
// lengths can be obtained with "i.get_dest_table()" and
// "i.get_int_table(index)".
//
class MethodByteCodeStream : public StackObj {
  // Handling for the weird bytecodes
  Bytecodes::Code EOBCs();	// End-of-ByteCodes
  Bytecodes::Code wide();	// Handle wide bytecode
  Bytecodes::Code table(Bytecodes::Code); // Handle complicated inline table
  Bytecodes::Code java(Bytecodes::Code); // Handle java-only fast bytecodes

  const methodHandle _method;   // the method
  address _bc_start;	       	// Start of current bytecode for table
  address _was_wide;		// Address past last wide bytecode
  address _restore_pc;		// Address to restore pc when running out of
  address _restore_end;		//   a nested bytecode buffer
  jint *_table_base;		// Aligned start of last table or switch 

public:
  enum {EOBC=257};
  MethodByteCodeStream( const methodHandle m ) : 
      _method(m), _bc_start(0), _was_wide(0), _restore_pc(0),
      _start(m->code_base()), _end(m->code_base() + m->code_size()) { 
    _pc = _start; }

  void Reset( address base, unsigned int size ) { 
    _bc_start =_was_wide =_restore_pc = 0; 
    _start = _pc = base; _end = base + size; }

  void reset_to_bci( int bci );

  void set_max_bci( int max ) {
    _end = _start + max;
  }
 
  address _start;		   // Start of bytecodes
  address _end;			   // Past end of bytecodes
  address _pc;			   // Current PC
  Bytecodes::Code _bc;             // Current bytecode

  address cur_bcp()             { return _bc_start; }  // Returns bcp to current instruction
  int next_bci() const          { return _pc -_start; }
  int cur_bci() const           { return _bc_start - _start; }

  Bytecodes::Code cur_bc()      { return _bc; }
  Bytecodes::Code next_bc()     { return (Bytecodes::Code)* _pc; }
  
  // Return current ByteCode and increment PC to next bytecode, skipping all
  // intermediate constants.  Returns EOBC at end.
  // Expected usage:
  //     while( (bc = iter.next()) != EndOfByteCodes ) { ... }
  Bytecodes::Code next() {
    _bc_start = _pc;		            // Capture start of bc
    if( _pc >= _end ) return EOBCs();       // End-Of-Bytecodes
    _bc = Bytecodes::code_at(_pc);         // Fetch bytecode
    int csize = Bytecodes::length_for(_bc); // Expected size
    if( _bc == Bytecodes::_wide ) 
      return (_bc=wide());	            // Handle wide bytecode
    if( csize == 0 ) return table(_bc);	    // Handle inline tables
    if( _bc > Bytecodes::_jsr_w)            // 
      return (_bc=java(_bc));	            // Java-fast BCs
    _pc += csize;		            // Bump PC past bytecode
    return _bc; 
  }

  bool is_wide()  { return ( _pc == _was_wide ); }
  bool is_active_breakpoint() { return Bytecodes::is_active_breakpoint_at(cur_bcp()); }

  // Get a byte index following this bytecode.
  // If prefixed with a wide bytecode, get a wide index.
  int get_index() const {
    return (_pc == _was_wide)	// was widened?
      ? Bytes::get_Java_u2(_bc_start+2)	// yes, return wide index
      : _bc_start[1];		// no, return narrow index
  }

  // Set a byte index following this bytecode.
  // If prefixed with a wide bytecode, get a wide index.
  void put_index(int idx) {
      if (_pc == _was_wide)	// was widened?
         Bytes::put_Java_u2(_bc_start+2,idx);	// yes, set wide index
      else
         _bc_start[1]=idx;		// no, set narrow index
  }

  // Get 2-byte index (getfield/putstatic/etc)
  int get_index_big() const { return Bytes::get_Java_u2(_bc_start+1); }

  // Get dimensions byte (multinewarray)
  int get_dimensions() const { return *(unsigned char*)(_pc-1); }

  // Get unsigned index fast
  int get_index_fast() const { return Bytes::get_native_u2(_pc-2); }

  // Sign-extended index byte/short, no widening
  int get_byte() const { return (signed char)(_pc[-1]); }
  int get_short() const { return (short)Bytes::get_Java_u2(_pc-2); }
  int get_long() const  { return (long)Bytes::get_Java_u4(_pc-4); }

  // Get a byte signed constant for "iinc".  Invalid for other bytecodes.
  // If prefixed with a wide bytecode, get a wide constant
  int get_iinc_con() const {return (_pc==_was_wide) ? get_short() :get_byte();}

  // 2-byte branch offset from current pc
  int get_dest( ) const {
    assert( Bytecodes::length_at(_bc_start) == sizeof(jshort)+1,  "dest2 called with bad bytecode" );
    return _bc_start-_start + (short)Bytes::get_Java_u2(_pc-2);
  }

  // 4-byte branch offset from current pc
  int get_far_dest( ) const {
    assert( Bytecodes::length_at(_bc_start) == sizeof(jint)+1, "dest4 called with bad bytecode" );
    return _bc_start-_start + (int)Bytes::get_Java_u4(_pc-4);
  }

  // For a lookup or switch table, return target destination 
  int get_int_table( int index ) const { 
    return Bytes::get_Java_u4((address)&_table_base[index]); }

  // For tableswitch - get length of offset part
  int get_tableswitch_length()  { return get_int_table(2)-get_int_table(1)+1; }

  int get_dest_table( int index ) const {
    return cur_bci() + get_int_table(index); }

};

