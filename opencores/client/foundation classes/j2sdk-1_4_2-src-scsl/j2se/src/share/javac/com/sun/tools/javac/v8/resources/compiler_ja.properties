#
# @(#)compiler_ja.properties	1.17 03/05/08
#
# Copyright 1999-2002 Sun Microsystems, Inc. All Rights Reserved.
#
# This software is the proprietary information of Sun Microsystems, Inc.
# Use is subject to license terms.
#

##
## errors
##

compiler.err.abstract.cant.be.instantiated=\
    {0} \u306f abstract \u3067\u3059\u3002\u30a4\u30f3\u30b9\u30bf\u30f3\u30b9\u3092\u751f\u6210\u3059\u308b\u3053\u3068\u306f\u3067\u304d\u307e\u305b\u3093\u3002
#    {0} is abstract; cannot be instantiated
compiler.err.abstract.meth.cant.have.body=\
    abstract \u30e1\u30bd\u30c3\u30c9\u304c\u672c\u4f53\u3092\u6301\u3064\u3053\u3068\u306f\u3067\u304d\u307e\u305b\u3093\u3002
#    abstract methods cannot have a body
compiler.err.already.defined=\
    {0} \u306f {1} \u3067\u5b9a\u7fa9\u3055\u308c\u3066\u3044\u307e\u3059\u3002
#    {0} is already defined in {1}
compiler.err.already.defined.single.import=\
    {0} \u306f\u5358\u4e00\u306e\u578b\u30a4\u30f3\u30dd\u30fc\u30c8\u5ba3\u8a00\u3067\u5b9a\u7fa9\u3055\u308c\u3066\u3044\u307e\u3059\u3002
#    {0} is already defined in a single-type import
compiler.err.already.defined.this.unit=\
    {0} \u306f\u30b3\u30f3\u30d1\u30a4\u30eb\u5358\u4f4d\u3067\u5b9a\u7fa9\u3055\u308c\u3066\u3044\u307e\u3059\u3002
#    {0} is already defined in this compilation unit
compiler.err.anon.class.impl.intf.no.args=\
    \u540d\u524d\u306e\u306a\u3044\u30af\u30e9\u30b9\u304c\u30a4\u30f3\u30bf\u30d5\u30a7\u30fc\u30b9\u3092\u5b9f\u88c5\u3057\u3066\u3044\u307e\u3059\u3002\u5f15\u6570\u3092\u6301\u3064\u3053\u3068\u306f\u3067\u304d\u307e\u305b\u3093\u3002
#    anonymous class implements interface; cannot have arguments
compiler.err.anon.class.impl.intf.no.qual.for.new=\
    \u540d\u524d\u306e\u306a\u3044\u30af\u30e9\u30b9\u304c\u30a4\u30f3\u30bf\u30d5\u30a7\u30fc\u30b9\u3092\u5b9f\u88c5\u3057\u3066\u3044\u307e\u3059\u3002new \u306b\u4fee\u98fe\u5b50\u3092\u6301\u3064\u3053\u3068\u306f\u3067\u304d\u307e\u305b\u3093\u3002
#    anonymous class implements interface; cannot have qualifier for new
compiler.err.array.dimension.missing=\
    \u914d\u5217\u306e\u5927\u304d\u3055\u304c\u6307\u5b9a\u3055\u308c\u3066\u3044\u307e\u305b\u3093\u3002
#    array dimension missing
compiler.err.array.req.but.found=\
    \u914d\u5217\u304c\u8981\u6c42\u3055\u308c\u307e\u3057\u305f\u304c\u3001{0} \u304c\u898b\u3064\u304b\u308a\u307e\u3057\u305f\u3002
#    array required, but {0} found

compiler.err.break.outside.switch.loop=\
    break \u304c switch \u6587\u307e\u305f\u306f\u30eb\u30fc\u30d7\u306e\u5916\u306b\u3042\u308a\u307e\u3059\u3002
#    break outside switch or loop

compiler.err.call.must.be.first.stmt.in.ctor=\
    {0} \u306e\u547c\u3073\u51fa\u3057\u306f\u30b3\u30f3\u30b9\u30c8\u30e9\u30af\u30bf\u306e\u5148\u982d\u6587\u3067\u306a\u3051\u308c\u3070\u306a\u308a\u307e\u305b\u3093\u3002
#    call to {0} must be first statement in constructor
compiler.err.cant.access=\
    {0} \u306b\u30a2\u30af\u30bb\u30b9\u3067\u304d\u307e\u305b\u3093\u3002{1}
#    cannot access {0}; {1}
compiler.err.cant.apply.symbol=\
    {1} \u306e {0} \u306f ({2}) \u306b\u9069\u7528\u3067\u304d\u307e\u305b\u3093\u3002
#    {0} in {1} cannot be applied to ({2})
compiler.err.cant.assign.val.to.final.var=\
    final \u5909\u6570 {0} \u306b\u5024\u3092\u4ee3\u5165\u3059\u308b\u3053\u3068\u306f\u3067\u304d\u307e\u305b\u3093\u3002
#    cannot assign a value to final variable {0}
compiler.err.cant.deref=\
    {0} \u306f\u9593\u63a5\u53c2\u7167\u3067\u304d\u307e\u305b\u3093\u3002
#    {0} cannot be dereferenced
compiler.err.cant.inherit.from.final=\
    final {0} \u304b\u3089\u306f\u7d99\u627f\u3067\u304d\u307e\u305b\u3093\u3002
#    cannot inherit from final {0}
compiler.err.cant.ref.before.ctor.called=\
    \u30b9\u30fc\u30d1\u30fc\u30bf\u30a4\u30d7\u306e\u30b3\u30f3\u30b9\u30c8\u30e9\u30af\u30bf\u306e\u547c\u3073\u51fa\u3057\u524d\u306f {0} \u3092\u53c2\u7167\u3067\u304d\u307e\u305b\u3093\u3002
#    cannot reference {0} before supertype constructor has been called
compiler.err.cant.ret.val.from.meth.decl.void=\
    \u623b\u308a\u5024\u306e\u578b\u304c void \u306e\u30e1\u30bd\u30c3\u30c9\u304b\u3089\u306f\u5024\u3092\u8fd4\u305b\u307e\u305b\u3093\u3002
#    cannot return a value from method whose result type is void
compiler.err.cant.select.static.class.from.param.type=\
    \u30d1\u30e9\u30e1\u30fc\u30bf\u306b\u3055\u308c\u305f\u578b\u304b\u3089 static \u30af\u30e9\u30b9\u3092\u9078\u629e\u3059\u308b\u3053\u3068\u306f\u3067\u304d\u307e\u305b\u3093\u3002
#    cannot select a static class from a parameterized type
compiler.err.cant.inherit.diff.arg=\
    {0} \u3092\u7570\u306a\u308b\u5f15\u6570 <{1}> \u3068 <{2}> \u3067\u7d99\u627f\u3059\u308b\u3053\u3068\u306f\u3067\u304d\u307e\u305b\u3093\u3002 
#    {0} cannot be inherited with different arguments: <{1}> and <{2}>
compiler.err.catch.without.try=\
    ''catch'' \u3078\u306e ''try'' \u304c\u3042\u308a\u307e\u305b\u3093\u3002
#    ''catch'' without ''try''
compiler.err.clash.with.pkg.of.same.name=\
    {0} \u306f\u540c\u540d\u306e\u30d1\u30c3\u30b1\u30fc\u30b8\u3068\u7af6\u5408\u3057\u307e\u3059\u3002
#    {0} clashes with package of same name
compiler.err.const.expr.req=\
    \u5b9a\u6570\u5f0f\u304c\u5fc5\u8981\u3067\u3059\u3002
#    constant expression required
compiler.err.cont.outside.loop=\
    continue \u304c\u30eb\u30fc\u30d7\u306e\u5916\u306b\u3042\u308a\u307e\u3059\u3002
#    continue outside of loop
compiler.err.cyclic.inheritance=\
    {0} \u3092\u542b\u3080\u7d99\u627f\u304c\u30eb\u30fc\u30d7\u3057\u3066\u3044\u307e\u3059\u3002
#    cyclic inheritance involving {0}

compiler.err.doesnt.exist=\
    \u30d1\u30c3\u30b1\u30fc\u30b8 {0} \u306f\u5b58\u5728\u3057\u307e\u305b\u3093\u3002
#    package {0} does not exist
compiler.err.duplicate.class=\
    \u30af\u30e9\u30b9 {0} \u304c\u91cd\u8907\u3057\u3066\u3044\u307e\u3059\u3002
#    duplicate class: {0}
compiler.err.duplicate.case.label=\
    case \u30e9\u30d9\u30eb\u304c\u91cd\u8907\u3057\u3066\u3044\u307e\u3059\u3002
#    duplicate case label
compiler.err.duplicate.default.label=\
    default \u30e9\u30d9\u30eb\u304c\u91cd\u8907\u3057\u3066\u3044\u307e\u3059\u3002
#    duplicate default label

compiler.err.else.without.if=\
    ''else'' \u3078\u306e ''if'' \u304c\u3042\u308a\u307e\u305b\u3093\u3002
#    ''else'' without ''if''
compiler.err.empty.char.lit=\
    \u7a7a\u306e\u6587\u5b57\u30ea\u30c6\u30e9\u30eb\u3067\u3059\u3002
#    empty character literal
compiler.err.encl.class.required=\
    {0} \u3092\u542b\u3080\u56f2\u3046\u30a4\u30f3\u30b9\u30bf\u30f3\u30b9\u304c\u5fc5\u8981\u3067\u3059\u3002
#    an enclosing instance that contains {0} is required
compiler.err.error.reading.file=\
    {0} \u306e\u8aad\u307f\u8fbc\u307f\u30a8\u30e9\u30fc\u3067\u3059\u3002{1}
#    error reading {0}; {1}
compiler.err.except.already.caught=\
    \u4f8b\u5916 {0} \u306f\u3059\u3067\u306b\u30ad\u30e3\u30c3\u30c1\u3055\u308c\u3066\u3044\u307e\u3059\u3002
#    exception {0} has already been caught
compiler.err.except.never.thrown.in.try=\
    \u4f8b\u5916 {0} \u306f\u5bfe\u5fdc\u3059\u308b try \u6587\u306e\u672c\u4f53\u3067\u306f\u30b9\u30ed\u30fc\u3055\u308c\u307e\u305b\u3093\u3002
#    exception {0} is never thrown in body of corresponding try statement

compiler.err.final.parameter.may.not.be.assigned=\
    final \u30d1\u30e9\u30e1\u30fc\u30bf {0} \u306b\u5024\u3092\u4ee3\u5165\u3059\u308b\u3053\u3068\u306f\u3067\u304d\u307e\u305b\u3093\u3002
#    final parameter {0} may not be assigned
compiler.err.finally.without.try=\
    ''finally'' \u3078\u306e ''try'' \u304c\u3042\u308a\u307e\u305b\u3093\u3002
#    ''finally'' without ''try''
compiler.err.fp.number.too.large=\
    \u6d6e\u52d5\u5c0f\u6570\u70b9\u6570\u304c\u5927\u304d\u904e\u304e\u307e\u3059\u3002
#    floating point number too large
compiler.err.fp.number.too.small=\
    \u6d6e\u52d5\u5c0f\u6570\u70b9\u6570\u304c\u5c0f\u3055\u904e\u304e\u307e\u3059\u3002
#    floating point number too small

compiler.err.icls.cant.have.static.decl=\
    \u5185\u90e8\u30af\u30e9\u30b9\u304c static \u5ba3\u8a00\u3092\u6301\u3064\u3053\u3068\u306f\u3067\u304d\u307e\u305b\u3093\u3002
#    inner classes cannot have static declarations
compiler.err.illegal.char=\
     \\{0} \u306f\u4e0d\u6b63\u306a\u6587\u5b57\u3067\u3059\u3002
#    illegal character: \\{0}
compiler.err.illegal.combination.of.modifiers=\
    \u4fee\u98fe\u5b50 {0} \u3068 {1} \u306e\u7d44\u307f\u5408\u308f\u305b\u306f\u4e0d\u6b63\u3067\u3059\u3002
#    illegal combination of modifiers: {0} and {1}
compiler.err.illegal.esc.char=\
    \u30a8\u30b9\u30b1\u30fc\u30d7\u6587\u5b57\u304c\u4e0d\u6b63\u3067\u3059\u3002
#    illegal escape character
compiler.err.illegal.forward.ref=\
    \u9806\u65b9\u5411\u53c2\u7167\u304c\u4e0d\u6b63\u3067\u3059\u3002
#    illegal forward reference
compiler.err.illegal.initializer.for.type=\
    {0} \u306e\u521d\u671f\u5316\u5b50\u304c\u4e0d\u6b63\u3067\u3059\u3002
#    illegal initializer for {0}
compiler.err.illegal.line.end.in.char.lit=\
    \u6587\u5b57\u30ea\u30c6\u30e9\u30eb\u306e\u884c\u672b\u304c\u4e0d\u6b63\u3067\u3059\u3002
#    illegal line end in character literal
compiler.err.illegal.qual.not.icls=\
    \u4fee\u98fe\u5b50\u304c\u4e0d\u6b63\u3067\u3059\u3002{0} \u306f\u5185\u90e8\u30af\u30e9\u30b9\u3067\u306f\u3042\u308a\u307e\u305b\u3093\u3002
#    illegal qualifier; {0} is not an inner class
compiler.err.illegal.start.of.expr=\
    \u5f0f\u306e\u958b\u59cb\u304c\u4e0d\u6b63\u3067\u3059\u3002
#    illegal start of expression
compiler.err.illegal.start.of.type=\
    \u578b\u306e\u958b\u59cb\u304c\u4e0d\u6b63\u3067\u3059\u3002
#    illegal start of type
compiler.err.illegal.unicode.esc=\
    Unicode \u30a8\u30b9\u30b1\u30fc\u30d7\u304c\u4e0d\u6b63\u3067\u3059\u3002
#    illegal unicode escape
compiler.err.import.requires.canonical=\
    \u30a4\u30f3\u30dd\u30fc\u30c8\u306b\u306f {0} \u306e\u6a19\u6e96\u540d\u304c\u5fc5\u8981\u3067\u3059\u3002
#    import requires canonical name for {0}
compiler.err.improperly.formed.type.param.missing=\
    \u578b\u306e\u5f62\u5f0f\u304c\u4e0d\u9069\u5207\u3067\u3059\u3002\u30d1\u30e9\u30e1\u30fc\u30bf\u304c\u4e0d\u8db3\u3057\u3066\u3044\u307e\u3059\u3002
#    improperly formed type, some parameters are missing
compiler.err.incomparable.types=\
    \u578b {0} \u3068 {1} \u306f\u6bd4\u8f03\u3067\u304d\u307e\u305b\u3093\u3002
#    incomparable types: {0} and {1}
compiler.err.int.number.too.large=\
    \u6574\u6570 {0} \u304c\u5927\u304d\u904e\u304e\u307e\u3059\u3002
#    integer number too large: {0}
compiler.err.internal.error.cant.instantiate=\
    \u5185\u90e8\u30a8\u30e9\u30fc\u3067\u3059\u3002{0} \u3092 {1} \u3067 ({2}) \u306b\u30a4\u30f3\u30b9\u30bf\u30f3\u30b9\u751f\u6210\u3067\u304d\u307e\u305b\u3093\u3002
#    internal error; cannot instantiate {0} at {1} to ({2})
compiler.err.intf.expected.here=\
    \u3053\u3053\u306b\u30a4\u30f3\u30bf\u30d5\u30a7\u30fc\u30b9\u304c\u5fc5\u8981\u3067\u3059\u3002
#    interface expected here
compiler.err.intf.meth.cant.have.body=\
    \u30a4\u30f3\u30bf\u30d5\u30a7\u30fc\u30b9\u30e1\u30bd\u30c3\u30c9\u304c\u672c\u4f53\u3092\u6301\u3064\u3053\u3068\u306f\u3067\u304d\u307e\u305b\u3093\u3002
#    interface methods cannot have body
compiler.err.invalid.hex.number=\
    16 \u9032\u6570\u306b\u306f 16 \u9032\u6570\u5b57\u304c\u6700\u4f4e 1 \u3064\u306f\u542b\u307e\u308c\u3066\u3044\u306a\u3051\u308c\u3070\u306a\u308a\u307e\u305b\u3093\u3002
#    hexadecimal numbers must contain at least one hexadecimal digit
compiler.err.invalid.meth.decl.ret.type.req=\
    \u30e1\u30bd\u30c3\u30c9\u306e\u5ba3\u8a00\u304c\u4e0d\u6b63\u3067\u3059\u3002\u623b\u308a\u5024\u306e\u578b\u304c\u5fc5\u8981\u3067\u3059\u3002
#    invalid method declaration; return type required

compiler.err.label.already.in.use=\
    \u30e9\u30d9\u30eb {0} \u306f\u3059\u3067\u306b\u4f7f\u308f\u308c\u3066\u3044\u307e\u3059\u3002
#    label {0} already in use
compiler.err.local.var.accessed.from.icls.needs.final=\
    \u30ed\u30fc\u30ab\u30eb\u5909\u6570 {0} \u306f\u5185\u90e8\u30af\u30e9\u30b9\u304b\u3089\u30a2\u30af\u30bb\u30b9\u3055\u308c\u307e\u3059\u3002final \u3067\u5ba3\u8a00\u3055\u308c\u308b\u5fc5\u8981\u304c\u3042\u308a\u307e\u3059\u3002
#    local variable {0} is accessed from within inner class; needs to be declared final

#
# limits.  We don't give the limits in the diagnostic because we expect
# them to change, yet we want to use the same diagnostic.  These are all
# detected during code generation.
#
compiler.err.limit.code=\
    \u30b3\u30fc\u30c9\u304c\u5927\u304d\u3059\u304e\u307e\u3059\u3002
#    code too large
compiler.err.limit.code.too.large.for.try.stmt=\
    try \u6587\u306e\u30b3\u30fc\u30c9\u304c\u5927\u304d\u3059\u304e\u307e\u3059\u3002
#    code too large for try statement
compiler.err.limit.dimensions=\
    \u914d\u5217\u578b\u306e\u6b21\u5143\u304c\u591a\u3059\u304e\u307e\u3059\u3002
#    array type has too many dimensions
compiler.err.limit.locals=\
    \u30ed\u30fc\u30ab\u30eb\u5909\u6570\u304c\u591a\u3059\u304e\u307e\u3059\u3002
#    too many local variables
compiler.err.limit.parameters=\
    \u30d1\u30e9\u30e1\u30fc\u30bf\u304c\u591a\u3059\u304e\u307e\u3059\u3002
#    too many parameters
compiler.err.limit.pool=\
    \u5b9a\u6570\u304c\u591a\u3059\u304e\u307e\u3059\u3002
#    too many constants
compiler.err.limit.pool.in.class=\
    \u30af\u30e9\u30b9 {0} \u5185\u306e\u5b9a\u6570\u304c\u591a\u3059\u304e\u307e\u3059\u3002
#    too many constants in class {0}
compiler.err.limit.stack=\
    \u30b3\u30fc\u30c9\u304c\u8981\u6c42\u3059\u308b\u30b9\u30bf\u30c3\u30af\u304c\u591a\u3059\u304e\u307e\u3059\u3002
#    code requires too much stack
compiler.err.limit.string=\
    \u5b9a\u6570\u6587\u5b57\u5217\u304c\u9577\u3059\u304e\u307e\u3059\u3002
#    constant string too long
compiler.err.limit.string.overflow=\
    \u6587\u5b57\u5217 \"{0}...\" \u306e UTF8 \u8868\u73fe\u304c\u3001\u5b9a\u6570\u30d7\u30fc\u30eb\u306b\u5bfe\u3057\u3066\u9577\u3059\u304e\u307e\u3059\u3002
#    UTF8 representation for string \"{0}...\" is too long for the constant pool

compiler.err.malformed.fp.lit=\
    \u6d6e\u52d5\u5c0f\u6570\u70b9\u30ea\u30c6\u30e9\u30eb\u304c\u4e0d\u6b63\u3067\u3059\u3002
#    malformed floating point literal
compiler.err.missing.meth.body.or.decl.abstract=\
    \u30e1\u30bd\u30c3\u30c9\u672c\u4f53\u304c\u306a\u3044\u304b\u3001abstract \u3068\u3057\u3066\u5ba3\u8a00\u3055\u308c\u3066\u3044\u307e\u3059\u3002
#    missing method body, or declare abstract
compiler.err.missing.ret.stmt=\
    return \u6587\u304c\u6307\u5b9a\u3055\u308c\u3066\u3044\u307e\u305b\u3093\u3002
#    missing return statement
compiler.err.missing.ret.val=\
    \u623b\u308a\u5024\u304c\u3042\u308a\u307e\u305b\u3093\u3002
#    missing return value
compiler.err.mod.not.allowed.here=\
    \u4fee\u98fe\u5b50 {0} \u3092\u3053\u3053\u3067\u4f7f\u3046\u3053\u3068\u306f\u3067\u304d\u307e\u305b\u3093\u3002
#    modifier {0} not allowed here

compiler.err.name.clash.same.erasure=\
    \u540d\u524d\u304c\u7af6\u5408\u3057\u3066\u3044\u307e\u3059\u3002{0} \u3068 {1} \u306f\u524a\u9664\u5f8c\u306e\u540d\u524d\u304c\u540c\u3058\u3067\u3059\u3002
#    name clash: {0} and {1} have the same erasure
compiler.err.name.clash.same.erasure.no.override=\
    \u540d\u524d\u304c\u7af6\u5408\u3057\u3066\u3044\u307e\u3059\u3002{1} \u306e {0} \u3068 {3} \u306e {2} \u306f\u307e\u3060\u4ed6\u65b9\u3092\u30aa\u30fc\u30d0\u30fc\u30e9\u30a4\u30c9\u3057\u3066\u3044\u307e\u305b\u3093\u304c\u3001\u524a\u9664\u5f8c\u306e\u540d\u524d\u304c\u540c\u3058\u3067\u3059\u3002
#    name clash: {0} in {1} and {2} in {3} have the same erasure, yet none overrides the other
compiler.err.name.reserved.for.internal.use=\
    {0} \u306f\u5185\u90e8\u3067\u306e\u4f7f\u7528\u306e\u305f\u3081\u4e88\u7d04\u3055\u308c\u3066\u3044\u307e\u3059\u3002
#    {0} is reserved for internal use
compiler.err.native.meth.cant.have.body=\
    native \u30e1\u30bd\u30c3\u30c9\u304c\u672c\u4f53\u3092\u6301\u3064\u3053\u3068\u306f\u3067\u304d\u307e\u305b\u3093\u3002
#    native methods cannot have a body
compiler.err.neither.conditional.subtype=\
 ? \u306b\u5bfe\u3059\u308b\u4e92\u63db\u6027\u306e\u306a\u3044\u578b : \u3069\u3061\u3089\u3082\u4ed6\u65b9\u306e\u30b5\u30d6\u30bf\u30a4\u30d7\u3067\u306f\u3042\u308a\u307e\u305b\u3093\u3002\n\
 2 \u756a\u76ee\u306e\u30aa\u30da\u30e9\u30f3\u30c9 : {0}\n\
 3 \u756a\u76ee\u306e\u30aa\u30da\u30e9\u30f3\u30c9 : {1}
# incompatible types for ?: neither is a subtype of the other\n\
# second operand: {0}\n\
# third operand : {1}
compiler.err.no.encl.instance.of.type.in.scope=\
    \u578b {0} \u306e\u5185\u90e8\u30af\u30e9\u30b9\u3092\u56f2\u3080\u30a4\u30f3\u30b9\u30bf\u30f3\u30b9\u304c\u30b9\u30b3\u30fc\u30d7\u5185\u306b\u3042\u308a\u307e\u305b\u3093\u3002
#    no enclosing instance of type {0} is in scope
compiler.err.no.intf.expected.here=\
    \u3053\u3053\u306b\u30a4\u30f3\u30bf\u30d5\u30a7\u30fc\u30b9\u306f\u5fc5\u8981\u3042\u308a\u307e\u305b\u3093\u3002
#    no interface expected here
compiler.err.no.match.entry=\
    {0} \u306f {1} \u306e\u30a8\u30f3\u30c8\u30ea\u306b\u9069\u5408\u3057\u307e\u305b\u3093\u3002{2} \u304c\u5fc5\u8981\u3067\u3059\u3002
#    {0} has no match in entry in {1}; required {2}
compiler.err.not.def.public.class.intf.cant.access=\
    {1} \u306e {0} \u306f public \u30af\u30e9\u30b9\u307e\u305f\u306f\u30a4\u30f3\u30bf\u30d5\u30a7\u30fc\u30b9\u3067\u306f\u5b9a\u7fa9\u3055\u308c\u307e\u305b\u3093\u3002\u30d1\u30c3\u30b1\u30fc\u30b8\u5916\u304b\u3089\u306f\u30a2\u30af\u30bb\u30b9\u3067\u304d\u307e\u305b\u3093\u3002
#    {0} in {1} is not defined in a public class or interface; cannot be accessed from outside package
compiler.err.not.def.public.cant.access=\
    {1} \u306e {0} \u306f public \u3067\u306f\u3042\u308a\u307e\u305b\u3093\u3002\u30d1\u30c3\u30b1\u30fc\u30b8\u5916\u304b\u3089\u306f\u30a2\u30af\u30bb\u30b9\u3067\u304d\u307e\u305b\u3093\u3002
#    {0} is not public in {1}; cannot be accessed from outside package
compiler.err.not.loop.label=\
    {0} \u306f\u30eb\u30fc\u30d7\u30e9\u30d9\u30eb\u3067\u306f\u3042\u308a\u307e\u305b\u3093\u3002
#    not a loop label: {0}
compiler.err.not.stmt=\
    \u6587\u3067\u306f\u3042\u308a\u307e\u305b\u3093\u3002
#    not a statement
compiler.err.not.encl.class=\
    {0} \u306f\u5185\u90e8\u30af\u30e9\u30b9\u3092\u56f2\u307f\u307e\u305b\u3093\u3002
#    not an enclosing class: {0}

compiler.err.operator.cant.be.applied=\
    \u6f14\u7b97\u5b50 {0} \u306f {1} \u306b\u9069\u7528\u3067\u304d\u307e\u305b\u3093\u3002
#    operator {0} cannot be applied to {1}

compiler.err.pkg.clashes.with.class.of.same.name=\
    \u30d1\u30c3\u30b1\u30fc\u30b8 {0} \u306f\u540c\u540d\u306e\u30af\u30e9\u30b9\u3068\u7af6\u5408\u3057\u3066\u3044\u307e\u3059\u3002
#    package {0} clashes with class of same name

compiler.err.qualified.new.of.static.class=\
    static \u30af\u30e9\u30b9\u306e new \u304c\u4fee\u98fe\u3055\u308c\u3066\u3044\u307e\u3059\u3002
#    qualified new of static class
compiler.err.recursive.ctor.invocation=\
    \u30b3\u30f3\u30b9\u30c8\u30e9\u30af\u30bf\u306e\u547c\u3073\u51fa\u3057\u304c\u518d\u5e30\u7684\u3067\u3059\u3002
#    recursive constructor invocation
compiler.err.ref.ambiguous=\
    {0} \u306e\u53c2\u7167\u306f\u3042\u3044\u307e\u3044\u3067\u3059\u3002{3} \u306e {1} {2} \u3068 {6} \u306e {4} {5} \u304c\u4e21\u65b9\u9069\u5408\u3057\u307e\u3059\u3002
#    reference to {0} is ambiguous, both {1} {2} in {3} and {4} {5} in {6} match
compiler.err.repeated.interface=\
    \u30a4\u30f3\u30bf\u30d5\u30a7\u30fc\u30b9\u304c\u7e70\u308a\u8fd4\u3055\u308c\u3066\u3044\u307e\u3059\u3002
#    repeated interface
compiler.err.repeated.modifier=\
    \u4fee\u98fe\u5b50\u304c\u7e70\u308a\u8fd4\u3055\u308c\u3066\u3044\u307e\u3059\u3002
#    repeated modifier
compiler.err.report.access=\
    {0} \u306f {2} \u3067 {1} \u30a2\u30af\u30bb\u30b9\u3055\u308c\u307e\u3059\u3002
#    {0} has {1} access in {2}
compiler.err.ret.outside.meth=\
    \u30e1\u30bd\u30c3\u30c9\u306e\u5916\u306e return \u6587\u3067\u3059\u3002
#    return outside method

compiler.err.signature.doesnt.match.supertype=\
    \u30b7\u30b0\u30cb\u30c1\u30e3\u30fc\u304c {0} \u306b\u9069\u5408\u3057\u307e\u305b\u3093\u3002\u4e92\u63db\u6027\u306e\u306a\u3044\u30b9\u30fc\u30d1\u30fc\u30bf\u30a4\u30d7\u3067\u3059\u3002
#    signature does not match {0}; incompatible supertype
compiler.err.signature.doesnt.match.intf=\
    \u30b7\u30b0\u30cb\u30c1\u30e3\u30fc\u304c {0} \u306b\u9069\u5408\u3057\u307e\u305b\u3093\u3002\u4e92\u63db\u6027\u306e\u306a\u3044\u30a4\u30f3\u30bf\u30d5\u30a7\u30fc\u30b9\u3067\u3059\u3002
#    signature does not match {0}; incompatible interfaces
compiler.err.does.not.override.abstract=\
    {0} \u306f abstract \u3067\u306a\u304f\u3001{2} \u5185\u306e abstract \u30e1\u30bd\u30c3\u30c9 {1} \u3092\u30aa\u30fc\u30d0\u30fc\u30e9\u30a4\u30c9\u3057\u307e\u305b\u3093\u3002
#    {0} is not abstract and does not override abstract method {1} in {2}
compiler.err.source.cant.overwrite.input.file=\
    \u30bd\u30fc\u30b9\u306e\u66f8\u304d\u8fbc\u307f\u30a8\u30e9\u30fc\u3067\u3059\u3002\u5165\u529b\u30d5\u30a1\u30a4\u30eb {0} \u3092\u4e0a\u66f8\u304d\u3067\u304d\u307e\u305b\u3093\u3002
#    error writing source; cannot overwrite input file {0}
compiler.err.synthetic.name.conflict=\
    \u30b7\u30f3\u30dc\u30eb {0} \u304c\u3001{1} \u3067\u30b3\u30f3\u30d1\u30a4\u30e9\u304c\u5408\u6210\u3057\u305f\u30b7\u30f3\u30dc\u30eb\u3068\u7af6\u5408\u3057\u307e\u3059\u3002
#    the symbol {0} conflicts with a compiler-synthesized symbol in {1}

compiler.err.try.without.catch.or.finally=\
    ''try'' \u3078\u306e ''catch'' \u307e\u305f\u306f ''finally'' \u304c\u3042\u308a\u307e\u305b\u3093\u3002
#    ''try'' without ''catch'' or ''finally''
compiler.err.type.doesnt.take.params=\
    \u578b {0} \u306f\u30d1\u30e9\u30e1\u30fc\u30bf\u3092\u3068\u308a\u307e\u305b\u3093\u3002
#    type {0} does not take parameters
compiler.err.type.var.cant.be.deref=\
    \u578b\u5909\u6570\u306f\u9593\u63a5\u53c2\u7167\u3067\u304d\u307e\u305b\u3093\u3002
#    type variables cannot be dereferenced
compiler.err.type.var.more.than.once=\
    \u578b\u5909\u6570 {0} \u306f {1} \u306e\u623b\u308a\u5024\u306e\u578b\u3067 2 \u56de\u4ee5\u4e0a\u51fa\u73fe\u3057\u307e\u3059\u3002\u30a4\u30f3\u30b9\u30bf\u30f3\u30b9\u751f\u6210\u3055\u308c\u306a\u3044\u307e\u307e\u306b\u306f\u3067\u304d\u307e\u305b\u3093\u3002
#    type variable {0} occurs more than once in result type of {1}; cannot be left uninstantiated
compiler.err.type.var.more.than.once.in.result=\
    \u578b\u5909\u6570 {0} \u306f {1} \u306e\u578b\u3067 2 \u56de\u4ee5\u4e0a\u51fa\u73fe\u3057\u307e\u3059\u3002\u30a4\u30f3\u30b9\u30bf\u30f3\u30b9\u751f\u6210\u3055\u308c\u306a\u3044\u307e\u307e\u306b\u306f\u3067\u304d\u307e\u305b\u3093\u3002
#    type variable {0} occurs more than once in type of {1}; cannot be left uninstantiated
compiler.err.types.incompatible.diff.ret=\
    \u578b {0} \u3068\u578b {1} \u306e\u4e92\u63db\u6027\u304c\u3042\u308a\u307e\u305b\u3093\u3002\u4e21\u65b9\u3068\u3082 {2} \u3092\u5b9a\u7fa9\u3057\u3066\u3044\u307e\u3059\u304c\u3001\u623b\u308a\u5024\u306e\u578b\u304c\u7570\u306a\u3063\u3066\u3044\u307e\u3059\u3002
#    types {0} and {1} are incompatible; both define {2}, but with different return type

compiler.err.unclosed.char.lit=\
    \u6587\u5b57\u30ea\u30c6\u30e9\u30eb\u304c\u9589\u3058\u3089\u308c\u3066\u3044\u307e\u305b\u3093\u3002
#    unclosed character literal
compiler.err.unclosed.comment=\
    \u30b3\u30e1\u30f3\u30c8\u304c\u9589\u3058\u3089\u308c\u3066\u3044\u307e\u305b\u3093\u3002
#    unclosed comment
compiler.err.unclosed.str.lit=\
    \u6587\u5b57\u5217\u30ea\u30c6\u30e9\u30eb\u304c\u9589\u3058\u3089\u308c\u3066\u3044\u307e\u305b\u3093\u3002
#    unclosed string literal
compiler.err.unsupported.encoding=\
     \u30b5\u30dd\u30fc\u30c8\u3055\u308c\u3066\u3044\u306a\u3044\u30a8\u30f3\u30b3\u30fc\u30c7\u30a3\u30f3\u30b0\u3067\u3059: {0}
#    unsupported encoding: {0}
compiler.err.io.exception=\
     \u30bd\u30fc\u30b9\u30d5\u30a1\u30a4\u30eb\u306e\u8aad\u307f\u53d6\u308a\u30a8\u30e9\u30fc\u3067\u3059: {0}
#    error reading source file: {0}
compiler.err.undef.label=\
    \u30e9\u30d9\u30eb {0} \u306f\u672a\u5b9a\u7fa9\u3067\u3059\u3002
#    undefined label: {0}
compiler.err.undetermined.type=\
    {0} \u306e\u578b\u30d1\u30e9\u30e1\u30fc\u30bf\u3092\u5224\u5225\u3067\u304d\u307e\u305b\u3093\u3002
#    type parameters of {0} cannot be determined
compiler.err.unreachable.stmt=\
    \u3053\u306e\u6587\u306b\u5236\u5fa1\u304c\u79fb\u308b\u3053\u3068\u306f\u3042\u308a\u307e\u305b\u3093\u3002
#    unreachable statement
compiler.err.initializer.must.be.able.to.complete.normally=\
    \u521d\u671f\u5316\u5b50\u306f\u6b63\u5e38\u306b\u5b8c\u4e86\u3067\u304d\u306a\u3051\u308c\u3070\u306a\u308a\u307e\u305b\u3093\u3002
#    initializer must be able to complete normally
compiler.err.unreported.exception.need.to.catch.or.throw=\
    \u4f8b\u5916 {0} \u306f\u5831\u544a\u3055\u308c\u307e\u305b\u3093\u3002\u30b9\u30ed\u30fc\u3059\u308b\u306b\u306f\u30ad\u30e3\u30c3\u30c1\u307e\u305f\u306f\u3001\u30b9\u30ed\u30fc\u5ba3\u8a00\u3092\u3057\u306a\u3051\u308c\u3070\u306a\u308a\u307e\u305b\u3093\u3002
#    unreported exception {0}; must be caught or declared to be thrown
compiler.err.unreported.exception.default.constructor=\
    \u30c7\u30d5\u30a9\u30eb\u30c8\u306e\u30b3\u30f3\u30b9\u30c8\u30e9\u30af\u30bf\u5185\u306b\u5831\u544a\u3055\u308c\u306a\u3044\u4f8b\u5916 {0} \u304c\u5b58\u5728\u3057\u307e\u3059\u3002
#    unreported exception {0} in default constructor
compiler.err.void.not.allowed.here=\
    \u3053\u3053\u3067 ''void'' \u578b\u3092\u4f7f\u7528\u3059\u308b\u3053\u3068\u306f\u3067\u304d\u307e\u305b\u3093\u3002
#    ''void'' type not allowed here

compiler.err.wrong.number.type.args=\
    \u578b\u5f15\u6570\u306e\u6570\u304c\u4e0d\u6b63\u3067\u3059\u3002{0} \u500b\u5fc5\u8981\u3067\u3059\u3002
#    wrong number of type arguments; required {0}

compiler.err.var.might.already.be.assigned=\
    \u5909\u6570 {0} \u306f\u3059\u3067\u306b\u4ee3\u5165\u3055\u308c\u3066\u3044\u308b\u53ef\u80fd\u6027\u304c\u3042\u308a\u307e\u3059\u3002
#    variable {0} might already have been assigned to
compiler.err.var.might.not.have.been.initialized=\
    \u5909\u6570 {0} \u306f\u521d\u671f\u5316\u3055\u308c\u3066\u3044\u306a\u3044\u53ef\u80fd\u6027\u304c\u3042\u308a\u307e\u3059\u3002
#    variable {0} might not have been initialized
compiler.err.var.might.be.assigned.in.loop=\
    \u5909\u6570 {0} \u306f\u30eb\u30fc\u30d7\u5185\u3067\u4ee3\u5165\u3055\u308c\u3066\u3044\u308b\u53ef\u80fd\u6027\u304c\u3042\u308a\u307e\u3059\u3002
#    variable {0} might be assigned in loop
compiler.err.assert.as.identifier=\
    \u30ea\u30ea\u30fc\u30b9 1.4 \u3067\u306f 'assert' \u306f\u30ad\u30fc\u30ef\u30fc\u30c9\u306a\u306e\u3067\u8b58\u5225\u5b50\u3068\u3057\u3066\u4f7f\u3046\u3053\u3068\u306f\u3067\u304d\u307e\u305b\u3093\u3002
#    as of release 1.4, 'assert' is a keyword, and may not be used as an identifier

# In the following string, {1} will always be the detail message from
# java.io.IOException.
compiler.err.class.cant.write=\
    {0} \u306e\u66f8\u304d\u8fbc\u307f\u4e2d\u306b\u30a8\u30e9\u30fc\u304c\u767a\u751f\u3057\u307e\u3057\u305f\u3002{1} 
#    error while writing {0}: {1}

# In the following string, {0} is the name of the class in the Java source.
# It really should be used two times..
compiler.err.class.public.should.be.in.file=\
    \u30af\u30e9\u30b9 {0} \u306f public \u3067\u3042\u308a\u3001\u30d5\u30a1\u30a4\u30eb {0}.java \u3067\u5ba3\u8a00\u3057\u306a\u3051\u308c\u3070\u306a\u308a\u307e\u305b\u3093\u3002
#    class {0} is public, should be declared in a file named {0}.java

## All errors which do not refer to a particular line in the source code are
## preceded by this string.
compiler.err.error=\
    \u30a8\u30e9\u30fc: 
#    error: 

# The following error messages do not refer to a line in the source code.
compiler.err.cant.read.file=\
    {0} \u3092\u8aad\u307f\u8fbc\u3081\u307e\u305b\u3093\u3002
#    cannot read: {0}

#####

# Fatal Errors

compiler.misc.fatal.err.no.java.lang=\
    \u81f4\u547d\u7684\u30a8\u30e9\u30fc: \u30af\u30e9\u30b9\u30d1\u30b9\u307e\u305f\u306f\u30d6\u30fc\u30c8\u30af\u30e9\u30b9\u30d1\u30b9\u3067\u30d1\u30c3\u30b1\u30fc\u30b8 java.lang \u3092\u691c\u51fa\u3067\u304d\u307e\u305b\u3093\u3002
#    Fatal Error: Unable to locate package java.lang in classpath or bootclasspath
compiler.misc.fatal.err.cant.locate.meth=\
    \u81f4\u547d\u7684\u30a8\u30e9\u30fc: \u30e1\u30bd\u30c3\u30c9 {0} \u3092\u691c\u51fa\u3067\u304d\u307e\u305b\u3093\u3002
#    Fatal Error: Unable to locate method {0}

#####

##
## miscellaneous strings
##

compiler.misc.source.unavailable=\
    (\u30bd\u30fc\u30b9\u304c\u5229\u7528\u4e0d\u53ef)
#    (source unavailable)
compiler.misc.base.membership=\
    \u3059\u3079\u3066\u306e\u57fa\u5e95\u30af\u30e9\u30b9\u304c\u3001\u30e1\u30f3\u30d0\u3067\u3059\u3002
#    all your base class are belong to us

#####

## The following string will appear before all messages keyed as:
## "compiler.note".
compiler.note.note=\
    \u6ce8: 
#    Note: 

compiler.note.deprecated.filename=\
    {0} \u306f\u63a8\u5968\u3055\u308c\u306a\u3044 API \u3092\u4f7f\u7528\u307e\u305f\u306f\u30aa\u30fc\u30d0\u30fc\u30e9\u30a4\u30c9\u3057\u3066\u3044\u307e\u3059\u3002
#    {0} uses or overrides a deprecated API.
compiler.note.deprecated.plural=\
    \u4e00\u90e8\u306e\u5165\u529b\u30d5\u30a1\u30a4\u30eb\u306f\u63a8\u5968\u3055\u308c\u306a\u3044 API \u3092\u4f7f\u7528\u307e\u305f\u306f\u30aa\u30fc\u30d0\u30fc\u30e9\u30a4\u30c9\u3057\u3066\u3044\u307e\u3059\u3002 
#    Some input files use or override a deprecated API.
# The following string will always appear after one of the above deprecation
# messages.
compiler.note.deprecated.recompile=\
    \u8a73\u7d30\u306b\u3064\u3044\u3066\u306f\u3001-deprecation \u30aa\u30d7\u30b7\u30e7\u30f3\u3092\u6307\u5b9a\u3057\u3066\u518d\u30b3\u30f3\u30d1\u30a4\u30eb\u3057\u3066\u304f\u3060\u3055\u3044\u3002
#    Recompile with -deprecation for details.

compiler.note.unchecked.filename=\
    {0} \u306f\u672a\u78ba\u8a8d\u306e\u30aa\u30da\u30ec\u30fc\u30b7\u30e7\u30f3\u3092\u4f7f\u3063\u3066\u3044\u307e\u3059\u3002
#    {0} uses unchecked operations.
compiler.note.unchecked.plural=\
    \u4e00\u90e8\u306e\u5165\u529b\u30d5\u30a1\u30a4\u30eb\u306f\u672a\u78ba\u8a8d\u306e\u30aa\u30da\u30ec\u30fc\u30b7\u30e7\u30f3\u3092\u4f7f\u3063\u3066\u3044\u307e\u3059\u3002
#    Some input files use unchecked operations.
# The following string will always appear after one of the above deprecation
# messages.
compiler.note.unchecked.recompile=\
    \u8a73\u7d30\u306b\u3064\u3044\u3066\u306f\u3001-warnunchecked \u30aa\u30d7\u30b7\u30e7\u30f3\u3092\u6307\u5b9a\u3057\u3066\u518d\u30b3\u30f3\u30d1\u30a4\u30eb\u3057\u3066\u304f\u3060\u3055\u3044\u3002
#    Recompile with -warnunchecked for details.

#####

compiler.misc.count.error=\
    \u30a8\u30e9\u30fc {0} \u500b
#    {0} error
compiler.misc.count.error.plural=\
    \u30a8\u30e9\u30fc {0} \u500b
#    {0} errors
compiler.misc.count.warn=\
    \u8b66\u544a {0} \u500b
#    {0} warning
compiler.misc.count.warn.plural=\
    \u8b66\u544a {0} \u500b
#    {0} warnings

## extra output when using -verbose (JavaCompiler)

compiler.misc.verbose.checking.attribution=\
    [{0} \u3092\u78ba\u8a8d\u4e2d]
#    [checking {0}]
compiler.misc.verbose.parsing.done=\
    [{0}ms \u3067\u69cb\u6587\u89e3\u6790\u5b8c\u4e86]
#    [parsing completed {0}ms]
compiler.misc.verbose.parsing.started=\
    [{0} \u3092\u69cb\u6587\u89e3\u6790\u958b\u59cb]
#    [parsing started {0}]
compiler.misc.verbose.total=\
    [\u5408\u8a08 {0}ms]
#    [total {0}ms]
compiler.misc.verbose.wrote.file=\
    [{0} \u3092\u66f8\u304d\u8fbc\u307f\u5b8c\u4e86]
#    [wrote {0}]

## extra output when using -verbose (Retro)
compiler.misc.verbose.retro=\
    [{0} \u3092\u7d44\u307f\u66ff\u3048\u4e2d]
#    [retrofitting {0}]
compiler.misc.verbose.retro.with=\
    \{0} \u3092 {1} \u3067\u7d44\u307f\u66ff\u3048\u4e2d\u3067\u3059\u3002
#    \tretrofitting {0} with {1}
compiler.misc.verbose.retro.with.list=\
    \{0} \u3092\u578b\u30d1\u30e9\u30e1\u30fc\u30bf {1}\u3001\u30b9\u30fc\u30d1\u30fc\u30bf\u30a4\u30d7 {2}\u3001\u30a4\u30f3\u30bf\u30d5\u30a7\u30fc\u30b9 {3} \u3067\u7d44\u307f\u66ff\u3048\u4e2d\u3067\u3059\u3002
#    \tretrofitting {0} with type parameters {1}, supertype {2}, interfaces {3}

## extra output when using -verbose (code/ClassReader)
compiler.misc.verbose.loading=\
    [{0} \u3092\u8aad\u307f\u8fbc\u307f\u4e2d]
#    [loading {0}]

## extra output when using -checkclassfile (code/ClassReader)
compiler.misc.ccf.found.later.version=\
   \u30af\u30e9\u30b9\u30d5\u30a1\u30a4\u30eb {0} \u306b\u4e88\u60f3\u5916\u306e\u65b0\u30d0\u30fc\u30b8\u30e7\u30f3\u304c\u3042\u308a\u307e\u3059\u3002 
#    class file has later version than expected: {0}
compiler.misc.ccf.unrecognized.attribute=\
   {0} \u306f\u8a8d\u8b58\u3055\u308c\u306a\u3044\u5c5e\u6027\u3067\u3059\u3002
#    unrecognized attribute: {0}

## extra output when using -prompt (util/Log)
compiler.misc.resume.abort=\
    R)\u518d\u958b, A)\u4e2d\u6b62>
#    R)esume, A)bort>

#####

##
## warnings
##

## All warning messages are preceded by the following string.
compiler.warn.warning=\
    \u8b66\u544a: 
#    warning: 

compiler.warn.assert.as.identifier=\
    \u30ea\u30ea\u30fc\u30b9 1.4 \u3067\u306f 'assert' \u306f\u30ad\u30fc\u30ef\u30fc\u30c9\u306a\u306e\u3067\u8b58\u5225\u5b50\u3068\u3057\u3066\u4f7f\u3046\u3053\u3068\u306f\u3067\u304d\u307e\u305b\u3093\u3002
#    as of release 1.4, 'assert' is a keyword, and may not be used as an identifier

compiler.warn.has.been.deprecated=\
    {1} \u306e {0} \u306f\u63a8\u5968\u3055\u308c\u307e\u305b\u3093\u3002
#    {0} in {1} has been deprecated

compiler.warn.finally.cannot.complete=\
    finally \u7bc0\u304c\u6b63\u5e38\u306b\u5b8c\u4e86\u3067\u304d\u307e\u305b\u3093\u3002
#    finally clause cannot complete normally

compiler.warn.illegal.nonascii.digit=\
    \u4e0d\u6b63\u306a\u975e ASCII \u6570\u5b57\u3067\u3059\u3002
#    illegal non-ASCII digit

compiler.warn.possible.fall-through.into.case=\
    case \u306b fall-through \u3059\u308b\u53ef\u80fd\u6027\u304c\u3042\u308a\u307e\u3059\u3002
#    possible fall-through into case

compiler.warn.unchecked.assign=\
    {0} \u304b\u3089 {1} \u306e\u4ee3\u5165\u306f\u672a\u78ba\u8a8d\u3067\u3059\u3002
#    unchecked assignment: {0} to {1}
compiler.warn.unchecked.assign.to.var=\
    raw \u578b {1} \u306e\u5909\u6570 {0} \u3078\u306e\u4ee3\u5165\u306f\u672a\u78ba\u8a8d\u3067\u3059\u3002
#    unchecked assignment to variable {0} of raw type class {1}
compiler.warn.unchecked.call.mbr.of.raw.type=\
    raw \u578b {1} \u306e\u30e1\u30f3\u30d0\u3068\u3057\u3066\u306e {0} \u306e\u547c\u3073\u51fa\u3057\u306f\u672a\u78ba\u8a8d\u3067\u3059\u3002
#    unchecked call to {0} as a member of the raw type {1}
compiler.warn.unchecked.cast.to.type=\
    \u578b {0} \u3078\u306e\u30ad\u30e3\u30b9\u30c8\u306f\u672a\u78ba\u8a8d\u3067\u3059\u3002
#    unchecked cast to type {0}
compiler.warn.unchecked.generic.array.creation=\
    \u6c4e\u7528\u914d\u5217\u306e\u4f5c\u6210\u306f\u672a\u78ba\u8a8d\u3067\u3059\u3002
#    unchecked generic array creation
compiler.warn.unchecked.meth.invocation.applied=\
    \u30e1\u30bd\u30c3\u30c9\u306e\u547c\u3073\u51fa\u3057\u304c\u672a\u78ba\u8a8d\u3067\u3059\u3002{1} \u306e {0} \u306f ({2}) \u306b\u9069\u7528\u3055\u308c\u307e\u3059\u3002
#    unchecked method invocation: {0} in {1} is applied to ({2})

#####

## The following are tokens which are non-terminals in the language. They should
## be named as JLS3 calls them when translated to the appropriate language.
compiler.misc.token.identifier=\
    <identifier>
#    <identifier>
compiler.misc.token.character=\
    <character>
#    <character>
compiler.misc.token.string=\
    <string>
#    <string>
compiler.misc.token.integer=\
    <integer>
#    <integer>
compiler.misc.token.long-integer=\
    <long integer>
#    <long integer>
compiler.misc.token.float=\
    <float>
#    <float>
compiler.misc.token.double=\
    <double>
#    <double>
compiler.misc.token.bad-symbol=\
    <bad symbol>
#    <bad symbol>
compiler.misc.token.end-of-input=\
    <end of input>
#    <end of input>

## The argument to the following string will always be one of the following:
## 1. one of the above non-terminals
## 2. a keyword (JLS1.8)
## 3. a boolean literal (JLS3.10.3)
## 4. the null literal (JLS3.10.7)
## 5. a Java separator (JLS3.11)
## 6. an operator (JLS3.12)
##
## This is the only place these tokens will be used.
compiler.err.expected=\
    {0} \u304c\u3042\u308a\u307e\u305b\u3093\u3002
#    {0} expected

## The following are related in form, but do not easily fit the above paradigm.
compiler.err.case.default.or.right-brace.expected=\
   ''case''\u3001''default''\u3001\u307e\u305f\u306f ''}'' \u304c\u3042\u308a\u307e\u305b\u3093\u3002
#   ''case'', ''default'' or ''}'' expected
compiler.err.class.or.intf.expected=\
    ''class'' \u307e\u305f\u306f ''interface'' \u304c\u3042\u308a\u307e\u305b\u3093\u3002
#    ''class'' or ''interface'' expected
compiler.err.dot.class.expected=\
    ''.class'' \u304c\u3042\u308a\u307e\u305b\u3093\u3002
#    ''.class'' expected
compiler.err.left-paren.or.left-square-bracket.expected=\
    ''('' \u307e\u305f\u306f ''['' \u304c\u3042\u308a\u307e\u305b\u3093\u3002
#    ''('' or ''['' expected

## The argument to this string will always be either 'case' or 'default'.
compiler.err.orphaned=\
    {0} \u306b\u306f\u89aa\u304c\u3042\u308a\u307e\u305b\u3093\u3002
#    orphaned {0}

compiler.misc.anonymous.class=\
    <anonymous {0}>
#    <anonymous {0}>

#####

compiler.err.cant.access=\
{0} \u306b\u30a2\u30af\u30bb\u30b9\u3067\u304d\u307e\u305b\u3093\u3002\n\
{1}
#cannot access {0}\n\
#{1}

compiler.misc.bad.class.file.header=\
\u30af\u30e9\u30b9\u30d5\u30a1\u30a4\u30eb {0} \u306f\u4e0d\u6b63\u3067\u3059\u3002\n\
{1}\n\
\u524a\u9664\u3059\u308b\u304b\u3001\u30af\u30e9\u30b9\u30d1\u30b9\u306e\u6b63\u3057\u3044\u30b5\u30d6\u30c7\u30a3\u30ec\u30af\u30c8\u30ea\u306b\u3042\u308b\u304b\u3092\u78ba\u8a8d\u3057\u3066\u304f\u3060\u3055\u3044\u3002
#bad class file: {0}\n\
#{1}\n\
#Please remove or make sure it appears in the correct subdirectory of the classpath.

## The following are all possible strings for the second argument ({1}) of the
## above strings.
compiler.misc.bad.class.signature=\
    \u30af\u30e9\u30b9 {0} \u306e\u30b7\u30b0\u30cb\u30c1\u30e3\u30fc\u304c\u4e0d\u6b63\u3067\u3059\u3002
#    bad class signature: {0}
compiler.misc.bad.const.pool.tag=\
    \u5b9a\u6570\u30d7\u30fc\u30eb\u30bf\u30b0 {0} \u304c\u4e0d\u6b63\u3067\u3059\u3002
#    bad constant pool tag: {0}
compiler.misc.bad.const.pool.tag.at=\
    \u5b9a\u6570\u30d7\u30fc\u30eb\u30bf\u30b0 {1} \u3067\u306e {0} \u304c\u4e0d\u6b63\u3067\u3059\u3002
#    bad constant pool tag: {0} at {1}
compiler.misc.bad.signature=\
    \u30b7\u30b0\u30cb\u30c1\u30e3\u30fc {0} \u304c\u4e0d\u6b63\u3067\u3059\u3002
#    bad signature: {0}
compiler.misc.class.file.wrong.class=\
    \u30af\u30e9\u30b9\u30d5\u30a1\u30a4\u30eb {0} \u306b\u4e0d\u6b63\u306a\u30af\u30e9\u30b9\u304c\u3042\u308a\u307e\u3059\u3002
#    class file contains wrong class: {0}
compiler.misc.dot.class.not.found=\
    \u30d5\u30a1\u30a4\u30eb {0}.class \u304c\u898b\u3064\u304b\u308a\u307e\u305b\u3093\u3002
#    file {0}.class not found
compiler.misc.file.doesnt.contain.class=\
    \u30d5\u30a1\u30a4\u30eb\u306b\u30af\u30e9\u30b9 {0} \u304c\u542b\u307e\u308c\u3066\u3044\u307e\u305b\u3093\u3002
#    file does not contain class {0}
compiler.misc.illegal.start.of.class.file=\
    \u30af\u30e9\u30b9\u30d5\u30a1\u30a4\u30eb\u306e\u958b\u59cb\u304c\u4e0d\u6b63\u3067\u3059\u3002
#    illegal start of class file
compiler.misc.unable.to.access.file=\
    \u30d5\u30a1\u30a4\u30eb {0} \u306b\u30a2\u30af\u30bb\u30b9\u3059\u308b\u3053\u3068\u304c\u3067\u304d\u307e\u305b\u3093\u3002
#    unable to access file: {0}
compiler.misc.unicode.str.not.supported=\
    \u30af\u30e9\u30b9\u30d5\u30a1\u30a4\u30eb\u5185\u306e Unicode \u6587\u5b57\u5217\u306f\u30b5\u30dd\u30fc\u30c8\u3055\u308c\u3066\u3044\u307e\u305b\u3093\u3002
#    unicode string in class file not supported
compiler.misc.undecl.type.var=\
    \u578b\u5909\u6570 {0} \u306f\u5ba3\u8a00\u3055\u308c\u3066\u3044\u307e\u305b\u3093\u3002
#    undeclared type variable: {0}
compiler.misc.wrong.version=\
    \u30af\u30e9\u30b9\u30d5\u30a1\u30a4\u30eb\u306e\u30d0\u30fc\u30b8\u30e7\u30f3 {0}.{1} \u306f\u4e0d\u6b63\u3067\u3059\u3002{2}.{3} \u3067\u3042\u308b\u3079\u304d\u3067\u3059\u3002
#    class file has wrong version {0}.{1}, should be {2}.{3}

#####

compiler.err.not.within.bounds=\
    \u578b\u30d1\u30e9\u30e1\u30fc\u30bf {0} \u306f\u305d\u306e\u7bc4\u56f2\u3092\u8d8a\u3048\u3066\u3044\u307e\u3059\u3002
#    type parameter {0} is not within its bound

compiler.err.not.within.bounds.explain=\
    \u578b\u30d1\u30e9\u30e1\u30fc\u30bf {0} \u306f\u305d\u306e\u7bc4\u56f2\u3092\u8d8a\u3048\u3066\u3044\u307e\u3059\u3002{1}
#    type parameter {0} is not within its bound; {1}

## The following are all possible strings for the second argument ({1}) of the
## above string.

## none yet...

#####

compiler.err.prob.found.req=\
{0}\n\
\u691c\u51fa\u5024  : {1}\n\
\u671f\u5f85\u5024  : {2}
#
#{0}\n\
#found   : {1}\n\
#required: {2}

## The following are all possible strings for the first argument ({0}) of the
## above string.
compiler.misc.incompatible.types=\
    \u4e92\u63db\u6027\u306e\u306a\u3044\u578b
#    incompatible types
compiler.misc.inconvertible.types=\
    \u5909\u63db\u3067\u304d\u306a\u3044\u578b
#    inconvertible types
compiler.misc.possible.loss.of.precision=\
    \u7cbe\u5ea6\u304c\u843d\u3061\u3066\u3044\u308b\u53ef\u80fd\u6027
#    possible loss of precision

#####

compiler.err.type.found.req=\
\u4e88\u671f\u3057\u306a\u3044\u578b\n\
\u691c\u51fa\u5024  : {0}\n\
\u671f\u5f85\u5024  : {1}
#
#unexpected type\n\
#found   : {0}\n\
#required: {1}

## The following are all possible strings for the first argument ({0}) of the
## above string.
compiler.misc.type.req.class=\
    \u30af\u30e9\u30b9
#    class
compiler.misc.type.req.class.array=\
    \u30af\u30e9\u30b9\u307e\u305f\u306f\u914d\u5217
#    class or array
compiler.misc.type.req.ref=\
    \u53c2\u7167
#    reference

#####

## The first argument ({0}) is a "kindname".
compiler.err.abstract.cant.be.accessed.directly=\
    abstract {0} {1} \u306b\u76f4\u63a5\u30a2\u30af\u30bb\u30b9\u3059\u308b\u3053\u3068\u306f\u3067\u304d\u307e\u305b\u3093\u3002
#    abstract {0} {1} cannot be accessed directly

## The first argument ({0}) is a "kindname".
compiler.err.non-static.cant.be.ref=\
    static \u3067\u306a\u3044 {0} {1} \u3092 static \u30b3\u30f3\u30c6\u30ad\u30b9\u30c8\u304b\u3089\u53c2\u7167\u3059\u308b\u3053\u3068\u306f\u3067\u304d\u307e\u305b\u3093\u3002
#    non-static {0} {1} cannot be referenced from a static context

## Both arguments ({0}, {1}) are "kindname"s.  {0} is a comma-separated list
## of kindnames (the list should be identical to that provided in source.
compiler.err.unexpected.type=\
\u4e88\u671f\u3057\u306a\u3044\u578b\n\
\u671f\u5f85\u5024  : {0}\n\
\u691c\u51fa\u5024  : {1}
#
#unexpected type\n\
#required: {0}\n\
#found   : {1}

## The first argument ({0}) is a "kindname".
compiler.err.cant.resolve=\
\u30b7\u30f3\u30dc\u30eb\u3092\u89e3\u6c7a\u3067\u304d\u307e\u305b\u3093\u3002\n\
\u30b7\u30f3\u30dc\u30eb: {0} {1} {2}
#
#cannot resolve symbol\n\
#symbol: {0} {1} {2}

## The first argument ({0}) and fifth argument ({4}) are "kindname"s.
compiler.err.cant.resolve.location=\
\u30b7\u30f3\u30dc\u30eb\u3092\u89e3\u6c7a\u3067\u304d\u307e\u305b\u3093\u3002\n\
\u30b7\u30f3\u30dc\u30eb: {0} {1} {2}\n\
\u5834\u6240    : {4} \u306e {3}
#
#cannot resolve symbol\n\
#symbol  : {0} {1} {2}\n\
#location: {3} {4}

## The first argument ({0}) and fifth argument ({4}) are "kindname"s.
compiler.err.cant.resolve.location.perchance=\
\u30b7\u30f3\u30dc\u30eb\u3092\u89e3\u6c7a\u3067\u304d\u307e\u305b\u3093\u3002\n\
\u30b7\u30f3\u30dc\u30eb: {0} {1} {2}\n\
\u5834\u6240    : {4} \u306e {3}\n\
''{5}'' \u3092\u610f\u56f3\u3057\u3066\u3044\u308b\u3068\u601d\u308f\u308c\u307e\u3059\u3002
#
#cannot resolve symbol\n\
#symbol  : {0} {1} {2}\n\
#location: {3} {4}\n\
#perchance you meant ''{5}''

## The following are all possible string for "kindname".
## They should be called whatever the JLS calls them after it been translated
## to the appropriate language.
compiler.misc.kindname.class=\
    \u30af\u30e9\u30b9
#    class
compiler.misc.kindname.constructor=\
    \u30b3\u30f3\u30b9\u30c8\u30e9\u30af\u30bf
#    constructor
compiler.misc.kindname.default=\
    \u8b58\u5225\u5b50({0})
#    identifier({0})
compiler.misc.kindname.interface=\
    \u30a4\u30f3\u30bf\u30d5\u30a7\u30fc\u30b9
#    interface
compiler.misc.kindname.method=\
    \u30e1\u30bd\u30c3\u30c9
#    method
compiler.misc.kindname.package=\
    \u30d1\u30c3\u30b1\u30fc\u30b8
#    package
compiler.misc.kindname.type.variable=\
    \u578b\u5909\u6570\u306e\u7bc4\u56f2
#    bound of type variable
compiler.misc.kindname.value=\
    \u5024
#    value
compiler.misc.kindname.variable=\
    \u5909\u6570
#    variable

#####

compiler.err.override.static=\
    {0}; \u30aa\u30fc\u30d0\u30fc\u30e9\u30a4\u30c9\u3059\u308b\u30e1\u30bd\u30c3\u30c9\u304c static \u3067\u3059\u3002
#    {0}; overriding method is static
compiler.err.override.meth=\
    {0}; \u30aa\u30fc\u30d0\u30fc\u30e9\u30a4\u30c9\u3055\u308c\u305f\u30e1\u30bd\u30c3\u30c9\u306f {1} \u3067\u3059\u3002
#    {0}; overriden method is {1}

# In the following string {1} is a space separated list of Java Keywords, as
# they would have been declared in the source code
compiler.err.override.weaker.access=\
    {0}\u30b9\u30fc\u30d1\u30fc\u30af\u30e9\u30b9\u3067\u306e\u5b9a\u7fa9\u3088\u308a\u5f31\u3044\u30a2\u30af\u30bb\u30b9\u7279\u6a29 ({1}) \u3092\u5272\u308a\u5f53\u3066\u3088\u3046\u3068\u3057\u307e\u3057\u305f\u3002
#    {0}; attempting to assign weaker access privileges; was {1}
compiler.err.override.meth.doesnt.throw=\
    {0}\u30aa\u30fc\u30d0\u30fc\u30e9\u30a4\u30c9\u3055\u308c\u305f\u30e1\u30bd\u30c3\u30c9\u306f {1} \u3092\u30b9\u30ed\u30fc\u3057\u307e\u305b\u3093\u3002
#    {0}; overriden method does not throw {1}

compiler.misc.override.incompatible.ret=\
    {0}\u4e92\u63db\u6027\u306e\u306a\u3044\u623b\u308a\u5024\u306e\u578b\u3092\u4f7f\u304a\u3046\u3068\u3057\u307e\u3057\u305f\u3002
#    {0}; attempting to use incompatible return type

## The following are all possible strings for the first argument ({0}) of the
## above strings.
compiler.misc.cant.override=\
    {1} \u306e {0} \u306f {3} \u306e {2} \u3092\u30aa\u30fc\u30d0\u30fc\u30e9\u30a4\u30c9\u3067\u304d\u307e\u305b\u3093\u3002
#    {0} in {1} cannot override {2} in {3}
compiler.misc.cant.implement=\
    {1} \u306e {0} \u306f {3} \u306e {2} \u3092\u5b9f\u88c5\u3067\u304d\u307e\u305b\u3093\u3002
#    {0} in {1} cannot implement {2} in {3}
compiler.misc.clashes.with=\
    {1} \u306e {0} \u306f {3} \u306e {2} \u3068\u7af6\u5408\u3057\u307e\u3059\u3002
#    {0} in {1} clashes with {2} in {3}
