/*
 * @(#)Configuration.java   1.43 01/12/03
 *
 * Copyright 2003 Sun Microsystems, Inc. All rights reserved.
 * SUN PROPRIETARY/CONFIDENTIAL. Use is subject to license terms.
 */

package com.sun.tools.doclets;

import com.sun.javadoc.*;
import java.util.*;
import java.io.*;

/**
 * Configure the output based on the options. Doclets should sub-class
 * Configuration, to configure and add their own options. This class contains
 * all user options which are supported by the 1.1 doclet and the standard
 * doclet.
 *
 * @author Robert Field.
 * @author Atul Dambalkar.
 */
public abstract class Configuration {

    /**
     * The default amount of space between tab stops.
     */
     public static final int DEFAULT_TAB_STOP_LENGTH = 8;
   
    /**
     * The source output directory name
     */
     public static final String SOURCE_OUTPUT_DIR_NAME = "src-html/";

    /**
     * The specified amount of space between tab stops.
     */
     public int linksourcetab = DEFAULT_TAB_STOP_LENGTH;
    
    /**
     * True if we should generate browsable sources.
     */
     public boolean genSrc = false;

    /**
     * True if command line option "-nosince" is used. Default value is
     * false.
     */
    public boolean nosince = false;

    /**
     * True if we should recursively copy the doc-file subdirectories
     */
    public boolean copydocfilesubdirs = false;
    
    /**
     * The META charset tag used for cross-platform viewing.
     */
    public String charset = "";
    
    /**
     * The list of doc-file subdirectories to exclude
     */
    protected Set excludedDocFileDirs;
    
    /**
     * The list of qualifiers to exclude
     */
    protected Set excludedQualifiers;
    
    /**
     * The Root of the generated Program Structure from the Doclet API.
     */
    public RootDoc root;
    
    /**
     * Destination directory name, in which doclet will generate the entire
     * documentation. Default is current directory.
     */
    public String destdirname = "";
    
    /**
     * Encoding for this document. Default is default encoding for this
     * platform.
     */
    public String docencoding = null;
    
    /**
     * Encoding for this document. Default is default encoding for this
     * platform.
     */
    public String encoding = null;
    
    /**
     * Generate author specific information for all the classes if @author
     * tag is used in the doc comment and if -author option is used.
     * <code>showauthor</code> is set to true if -author option is used.
     * Default is don't show author information.
     */
    public boolean showauthor = false;
    
    /**
     * Generate version specific information for the all the classes
     * if @version tag is used in the doc comment and if -version option is
     * used. <code>showversion</code> is set to true if -version option is
     * used.Default is don't show version information.
     */
    public boolean showversion = false;
    
    /**
     * Don't generate the date in the generated documentation, if -nodate
     * option is used. <code>nodate</code> is set to true if -nodate
     * option is used. Default is don't show date.
     */
    public boolean nodate = false;
    
    /**
     * Sourcepath from where to read the source files. Default is classpath.
     *
     */
    public String sourcepath = "";
    
    /**
     * Don't generate deprecated API information at all, if -nodeprecated
     * option is used. <code>nodepracted</code> is set to true if
     * -nodeprecated option is used. Default is generate deprected API
     * information.
     */
    public boolean nodeprecated = false;
    
    /**
     * All the packages to be documented.
     */
    public PackageDoc[] packages;

    /**
     * The catalog of classes specified on the command-line
     */
    public ClassDocCatalog classDocCatalog;
    
    /**
     * Message Retriever for the doclet, to retrieve message from the resource
     * file for this Configuration, which is common for 1.1 and standard
     * doclets.
     */
    public MessageRetriever message = null;
    
    /**
     * This method should be defined in all those doclets(configurations),
     * which want to derive themselves from this Configuration. This method
     * can be used to set its own command line options.
     *
     * @param root Root of the Program Structure generated by Javadoc.
     * @throws DocletAbortException
     */
    public abstract void setSpecificDocletOptions(RootDoc root) ;
    
    /**
     * This method should be defined in all those doclets
     * which want to inherit from this Configuration. This method
     * should return the number of arguments to the command line option.
     * This method is called by the method {@link #optionLength(String)}.
     *
     * @param option Command line option under consideration.
     * @return number of arguments to option. Zero return means
     * option not known.  Negative value means error occurred.
     * @see #optionLength(String)
     */
    public abstract int optionLength(String option);
    
    /**
     * Constructor. Constructs the message retriever with resource file.
     */
    public Configuration() {
        message =
            new MessageRetriever(this,
                                 "com.sun.tools.doclets.resources.doclets");
        excludedDocFileDirs = new HashSet();
        excludedQualifiers = new HashSet();
    }
    
    /**
     * Set the command line options supported by this configuration.
     *
     * @param root Root of the Program Structure generated by this Javadoc run.
     * @throws DocletAbortException
     */
    public void setOptions(RootDoc root) {
        String[][] options = root.options();
        this.root = root;
        for (int oi = 0; oi < options.length; ++oi) {
            String[] os = options[oi];
            String opt = os[0].toLowerCase();
            if (opt.equals("-d")) {
                destdirname = addTrailingFileSep(os[1]);
            } else  if (opt.equals("-docfilessubdirs")) {
                copydocfilesubdirs = true;
            } else  if (opt.equals("-docencoding")) {
                docencoding = os[1];
            } else  if (opt.equals("-encoding")) {
                encoding = os[1];
            } else  if (opt.equals("-author")) {
                showauthor = true;
            } else  if (opt.equals("-version")) {
                showversion = true;
            } else  if (opt.equals("-nodeprecated")) {
                nodeprecated = true;
            } else  if (opt.equals("-xnodate")) {
                nodate = true;
            } else  if (opt.equals("-sourcepath")) {
                sourcepath = os[1];
            } else if (opt.equals("-classpath") &&
                       sourcepath.length() == 0) {
                sourcepath = os[1];
            } else if (opt.equals("-excludedocfilessubdir")) {
                addToSet(excludedDocFileDirs, os[1]);
            } else if (opt.equals("-noqualifier")) {
                addToSet(excludedQualifiers, os[1]);
            } else if (opt.equals("-linksource")) {
                genSrc = true;
            } else if (opt.equals("-linksourcetab")) {
                genSrc = true;
                try {
                    linksourcetab = Integer.parseInt(os[1]);
                } catch (NumberFormatException e) {
                    //Set to -1 so that warning will be printed
                    //to indicate what is valid argument.
                    linksourcetab = -1;
                }
                if (linksourcetab <= 0) {
                    message.warning("doclet.linksourcetab_warning");
                    linksourcetab = DEFAULT_TAB_STOP_LENGTH;
                }
            }
        }
        if (sourcepath.length() == 0) {
            sourcepath = System.getProperty("env.class.path");
        }
        if (docencoding == null) {
            docencoding = encoding;
        }
        
        packages = root.specifiedPackages();
        classDocCatalog = new ClassDocCatalog(root.specifiedClasses());
        Arrays.sort(packages);
        setSpecificDocletOptions(root);
    }
    
    protected void addToSet(Set s, String str){
        StringTokenizer st = new StringTokenizer(str, ":");
        String current;
        while(st.hasMoreTokens()){
            current = st.nextToken();
            s.add(current);
        }
    }
    
    /**
     * Add a traliling file separator, if not found or strip off extra trailing
     * file separators if any.
     *
     * @param path Path under consideration.
     * @return String Properly constructed path string.
     */
    String addTrailingFileSep(String path) {
        String fs = System.getProperty("file.separator");
        String dblfs = fs + fs;
        int indexDblfs;
        while ((indexDblfs = path.indexOf(dblfs)) >= 0) {
            path = path.substring(0, indexDblfs) +
                path.substring(indexDblfs + fs.length());
        }
        if (!path.endsWith(fs))
            path += fs;
        return path;
    }
    
    /**
     * Check for doclet added options here. This works exactly like
     * {@link com.sun.javadoc.Doclet#optionLength(String)}. This
     * will return the length of the options which are shared
     * by our doclets.
     *
     * @param option Option whose length is requested.
     * @return number of arguments to option. Zero return means
     * option not known.  Negative value means error occurred.
     */
    public int generalOptionLength(String option) {
        option = option.toLowerCase();
        if (option.equals("-docfilessubdirs") ||
            option.equals("-linksource") ||
            option.equals("-version") ||
            option.equals("-nodeprecated") ||
            option.equals("-author") ||
            option.equals("-xnodate")) {
            return 1;
        } else if (option.equals("-docencoding") ||
                   option.equals("-encoding") ||
                   option.equals("-excludedocfilessubdir") ||
                   option.equals("-noqualifier") ||
                   option.equals("-sourcepath") ||
                   option.equals("-d") /*||
                   option.equals("-linksourcetab")*/ ) {
            return 2;
        } else {
            return -1;  // indicate we don't know about it
        }
    }
    
    /**
     * This checks for the validity of the options used by the user.
     * This works exactly like
     * {@link com.sun.javadoc.Doclet#validOptions(String[][],
     * DocErrorReporter)}. This will validate the options which are shared
     * by our doclets. For example, this method will flag an error using
     * the DocErrorReporter if user has used "-nohelp" and "-helpfile" option
     * together.
     *
     * @param options  Options used on the command line.
     * @param reporter Error reporter to be used.
     * @return true if all the options are valid.
     */
    public boolean generalValidOptions(String options[][],
                                       DocErrorReporter reporter) {
        boolean docencodingfound = false;
        String encoding = "";
        for (int oi = 0; oi < options.length; oi++) {
            String[] os = options[oi];
            String opt = os[0].toLowerCase();
            if (opt.equals("-d")) {
                String destdirname = addTrailingFileSep(os[1]);
                File destDir = new File(destdirname);
                if (!destDir.exists()) {
                    //Create the output directory (in case it doesn't exist yet)
                    (new File(destdirname)).mkdirs();
                } else if (!destDir.isDirectory()) {
                    reporter.printError(message.getText(
                                            "doclet.destination_directory_not_directory_0",
                                            destDir.getPath()));
                    return false;
                } else if (!destDir.canWrite()) {
                    reporter.printError(message.getText(
                                            "doclet.destination_directory_not_writable_0",
                                            destDir.getPath()));
                    return false;
                }
            } else if (opt.equals("-docencoding")) {
                docencodingfound = true;
                if (!checkOutputFileEncoding(os[1], reporter)) {
                    return false;
                }
            } else if (opt.equals("-encoding")) {
                encoding = os[1];
            }
        }
        if (!docencodingfound && encoding.length() > 0) {
            if (!checkOutputFileEncoding(encoding, reporter)) {
                return false;
            }
        }
        return true;
    }
    
    /**
     * Check the validity of the given Source or Output File encoding on this
     * platform.
     *
     * @param docencoding Output file encoding.
     * @param reporter    Error reporter object.
     */
    protected boolean checkOutputFileEncoding(String docencoding,
                                              DocErrorReporter reporter) {
        OutputStream ost= new ByteArrayOutputStream();
        OutputStreamWriter osw = null;
        try {
            osw = new OutputStreamWriter(ost, docencoding);
        } catch (UnsupportedEncodingException exc) {
            reporter.printError(message.getText(
                                    "doclet.Encoding_not_supported", docencoding));
            return false;
        } finally {
            try {
                if (osw != null) {
                    osw.close();
                }
            } catch (IOException exc) {
            }
        }
        return true;
    }
    
    /**
     * Return true if the given doc-file subdirectory should be excluded and
     * false otherwise.
     * @param docfilesubdir the doc-files subdirectory to check.
     */
     public boolean shouldExcludeDocFileDir(String docfilesubdir){
         if (excludedDocFileDirs.contains(docfilesubdir)) {
             return true;
         } else {
             return false;
         }
    }
    
    /**
     * Return true if the given qualifier should be excluded and false otherwise.
     * @param qualifier the qualifier to check.
     */
     public boolean shouldExcludeQualifier(String qualifier){
         if (excludedQualifiers.contains("all") || excludedQualifiers.contains(qualifier)) {
             return true;
         } else {
             int index = -1;
             while ((index = qualifier.indexOf(".", index + 1)) != -1) {
                 if (excludedQualifiers.contains(qualifier.substring(0, index + 1) + "*")) {
                     return true;
                 }
             }
             return false;
         }
    }
    
    /**
     * Return the qualified name of the <code>ClassDoc</code> if it's qualifier is not excluded.  Otherwise,
     * return the unqualified <code>ClassDoc</code> name.
     * @param cd the <code>ClassDoc</code> to check.
     */
     public String getClassName(ClassDoc cd) {
          
         PackageDoc pd = cd.containingPackage();
         if (pd != null && shouldExcludeQualifier(cd.containingPackage().name())) {
             return cd.name();
         } else {
             return cd.qualifiedName();
         }
    }
}


