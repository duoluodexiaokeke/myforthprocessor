/*
 * @(#)FieldAccessorGenerator.java	1.8 03/01/23
 *
 * Copyright 2003 Sun Microsystems, Inc. All rights reserved.
 * SUN PROPRIETARY/CONFIDENTIAL. Use is subject to license terms.
 */

package sun.reflect;

import java.lang.reflect.*;
import java.security.AccessController;
import java.security.PrivilegedAction;
import sun.misc.Unsafe;

/** Generator for sun.reflect.FieldAccessor objects using bytecodes to
    implement reflection. A java.lang.reflect.Field object can
    delegate its get and set methods to a sun.misc.Unsafe-based
    FieldAccessor or to one generated by this class. */

class FieldAccessorGenerator extends AccessorGenerator {

    private static final short NUM_BASE_CPOOL_ENTRIES         = (short) 46;
    private static final short NUM_NONPRIMITIVE_CPOOL_ENTRIES = (short) 2;
    private static final short NUM_FINAL_FIELD_CPOOL_ENTRIES  = (short) 5;
    // All accessors plus one for constructor
    private static final short NUM_METHODS                    = (short) 19;

    private static volatile int symnum = 0;

    private Class type;
    private short targetFieldRef;
    private short targetFieldType;
    // Names and descriptors for methods the generated class contains
    private short getIdx;
    private short getBooleanIdx;
    private short getByteIdx;
    private short getCharIdx;
    private short getShortIdx;
    private short getIntIdx;
    private short getLongIdx;
    private short getFloatIdx;
    private short getDoubleIdx;
    private short setIdx;
    private short setBooleanIdx;
    private short setByteIdx;
    private short setCharIdx;
    private short setShortIdx;
    private short setIntIdx;
    private short setLongIdx;
    private short setFloatIdx;
    private short setDoubleIdx;
    // Support for throwing IllegalAccessException for final fields
    private short fieldIsFinalIdx;
    private short illegalAccessClass;
    private short illegalAccessStringCtorIdx;
  
    FieldAccessorGenerator()
    {
    }

    /** This routine is not thread-safe */
    public FieldAccessor generate(final Class declaringClass,
                                  String name,
                                  Class type,
                                  int modifiers)
    {
        ByteVector vec = ByteVectorFactory.create();
        asm = new ClassFileAssembler(vec);
        this.type = type;
        this.modifiers = modifiers;

        asm.emitMagicAndVersion();

        // Constant pool entries:
        // ( * = Boxing information: optional)
        // (** = Only if target field is non-primitive)
        // (+  = Shared entries provided by AccessorGenerator)
        // (++ = Only present if field is final)
        //     [UTF-8] [This class's name]
        //     [CONSTANT_Class_info] for above
        //     [UTF-8] "sun/reflect/FieldAccessorImpl"
        //     [CONSTANT_Class_info] for above
        //     [UTF-8] [Target class's name]
        //     [CONSTANT_Class_info] for above
        //     [UTF-8] target field name
        //     [UTF-8] target field type DESCRIPTOR
        //     [CONSTANT_NameAndType_info] for above
        //     [CONSTANT_Fieldref_info] for target field
        // **  [UTF-8] target field type name
        // **  [CONSTANT_Class_info] for target field's type
        //     [UTF-8] "get"
        //     [UTF-8] "(Ljava/lang/Object;)Ljava/lang/Object;"  (get descriptor)
        //     [UTF-8] "getBoolean"
        //     [UTF-8] "(Ljava/lang/Object;)Z"                   (getBoolean descriptor)
        //     [UTF-8] "getByte"
        //     [UTF-8] "(Ljava/lang/Object;)B"                   (getByte descriptor)
        //     [UTF-8] "getChar"
        //     [UTF-8] "(Ljava/lang/Object;)C"                   (getChar descriptor)
        //     [UTF-8] "getShort"
        //     [UTF-8] "(Ljava/lang/Object;)S"                   (getShort descriptor)
        //     [UTF-8] "getInt"
        //     [UTF-8] "(Ljava/lang/Object;)I"                   (getInt descriptor)
        //     [UTF-8] "getLong"
        //     [UTF-8] "(Ljava/lang/Object;)J"                   (getLong descriptor)
        //     [UTF-8] "getFloat"
        //     [UTF-8] "(Ljava/lang/Object;)F"                   (getFloat descriptor)
        //     [UTF-8] "getDouble"
        //     [UTF-8] "(Ljava/lang/Object;)D"                   (getDouble descriptor)
        //     [UTF-8] "set"
        //     [UTF-8] "(Ljava/lang/Object;Ljava/lang/Object;)V" (set descriptor)
        //     [UTF-8] "setBoolean"
        //     [UTF-8] "(Ljava/lang/Object;Z)V"                  (setBoolean descriptor)
        //     [UTF-8] "setByte"
        //     [UTF-8] "(Ljava/lang/Object;B)V"                  (setByte descriptor)
        //     [UTF-8] "setChar"
        //     [UTF-8] "(Ljava/lang/Object;C)V"                  (setChar descriptor)
        //     [UTF-8] "setShort"
        //     [UTF-8] "(Ljava/lang/Object;S)V"                  (setShort descriptor)
        //     [UTF-8] "setInt"
        //     [UTF-8] "(Ljava/lang/Object;I)V"                  (setInt descriptor)
        //     [UTF-8] "setLong"
        //     [UTF-8] "(Ljava/lang/Object;J)V"                  (setLong descriptor)
        //     [UTF-8] "setFloat"
        //     [UTF-8] "(Ljava/lang/Object;F)V"                  (setFloat descriptor)
        //     [UTF-8] "setDouble"
        //     [UTF-8] "(Ljava/lang/Object;D)V"                  (setDouble descriptor)
        // +   [UTF-8] "java/lang/Exception"
        // +   [CONSTANT_Class_info] for above
        // +   [UTF-8] "java/lang/ClassCastException"
        // +   [CONSTANT_Class_info] for above
        // +   [UTF-8] "java/lang/NullPointerException"
        // +   [CONSTANT_Class_info] for above
        // +   [UTF-8] "java/lang/IllegalArgumentException"
        // +   [CONSTANT_Class_info] for above
        // +   [UTF-8] "java/lang/InvocationTargetException"
        // +   [CONSTANT_Class_info] for above
        // +   [UTF-8] "<init>"
        // +   [UTF-8] "()V"
        // +   [CONSTANT_NameAndType_info] for above
        // +   [CONSTANT_Methodref_info] for NullPointerException's constructor
        // +   [CONSTANT_Methodref_info] for IllegalArgumentException's constructor
        // +   [UTF-8] "(Ljava/lang/String;)V"
        // +   [CONSTANT_NameAndType_info] for "<init>(Ljava/lang/String;)V"
        // +   [CONSTANT_Methodref_info] for IllegalArgumentException's constructor taking a String
        // +   [UTF-8] "(Ljava/lang/Throwable;)V"
        // +   [CONSTANT_NameAndType_info] for "<init>(Ljava/lang/Throwable;)V"
        // +   [CONSTANT_Methodref_info] for InvocationTargetException's constructor
        // +   [CONSTANT_Methodref_info] for "super()"
        // +   [UTF-8] "java/lang/Object"
        // +   [CONSTANT_Class_info] for above
        // +   [UTF-8] "toString"
        // +   [UTF-8] "()Ljava/lang/String;"
        // +   [CONSTANT_NameAndType_info] for "toString()Ljava/lang/String;"
        // +   [CONSTANT_Methodref_info] for Object's toString method
        // +   [UTF-8] "Code"
        // +   [UTF-8] "Exceptions"
        //  *  [UTF-8] "java/lang/Boolean"
        //  *  [CONSTANT_Class_info] for above
        //  *  [UTF-8] "(Z)V"
        //  *  [CONSTANT_NameAndType_info] for above
        //  *  [CONSTANT_Methodref_info] for above
        //  *  [UTF-8] "booleanValue"
        //  *  [UTF-8] "()Z"
        //  *  [CONSTANT_NameAndType_info] for above
        //  *  [CONSTANT_Methodref_info] for above
        //  *  [UTF-8] "java/lang/Byte"
        //  *  [CONSTANT_Class_info] for above
        //  *  [UTF-8] "(B)V"
        //  *  [CONSTANT_NameAndType_info] for above
        //  *  [CONSTANT_Methodref_info] for above
        //  *  [UTF-8] "byteValue"
        //  *  [UTF-8] "()B"
        //  *  [CONSTANT_NameAndType_info] for above
        //  *  [CONSTANT_Methodref_info] for above
        //  *  [UTF-8] "java/lang/Character"
        //  *  [CONSTANT_Class_info] for above
        //  *  [UTF-8] "(C)V"
        //  *  [CONSTANT_NameAndType_info] for above
        //  *  [CONSTANT_Methodref_info] for above
        //  *  [UTF-8] "charValue"
        //  *  [UTF-8] "()C"
        //  *  [CONSTANT_NameAndType_info] for above
        //  *  [CONSTANT_Methodref_info] for above
        //  *  [UTF-8] "java/lang/Double"
        //  *  [CONSTANT_Class_info] for above
        //  *  [UTF-8] "(D)V"
        //  *  [CONSTANT_NameAndType_info] for above
        //  *  [CONSTANT_Methodref_info] for above
        //  *  [UTF-8] "doubleValue"
        //  *  [UTF-8] "()D"
        //  *  [CONSTANT_NameAndType_info] for above
        //  *  [CONSTANT_Methodref_info] for above
        //  *  [UTF-8] "java/lang/Float"
        //  *  [CONSTANT_Class_info] for above
        //  *  [UTF-8] "(F)V"
        //  *  [CONSTANT_NameAndType_info] for above
        //  *  [CONSTANT_Methodref_info] for above
        //  *  [UTF-8] "floatValue"
        //  *  [UTF-8] "()F"
        //  *  [CONSTANT_NameAndType_info] for above
        //  *  [CONSTANT_Methodref_info] for above
        //  *  [UTF-8] "java/lang/Integer"
        //  *  [CONSTANT_Class_info] for above
        //  *  [UTF-8] "(I)V"
        //  *  [CONSTANT_NameAndType_info] for above
        //  *  [CONSTANT_Methodref_info] for above
        //  *  [UTF-8] "intValue"
        //  *  [UTF-8] "()I"
        //  *  [CONSTANT_NameAndType_info] for above
        //  *  [CONSTANT_Methodref_info] for above
        //  *  [UTF-8] "java/lang/Long"
        //  *  [CONSTANT_Class_info] for above
        //  *  [UTF-8] "(J)V"
        //  *  [CONSTANT_NameAndType_info] for above
        //  *  [CONSTANT_Methodref_info] for above
        //  *  [UTF-8] "longValue"
        //  *  [UTF-8] "()J"
        //  *  [CONSTANT_NameAndType_info] for above
        //  *  [CONSTANT_Methodref_info] for above
        //  *  [UTF-8] "java/lang/Short"
        //  *  [CONSTANT_Class_info] for above
        //  *  [UTF-8] "(S)V"
        //  *  [CONSTANT_NameAndType_info] for above
        //  *  [CONSTANT_Methodref_info] for above
        //  *  [UTF-8] "shortValue"
        //  *  [UTF-8] "()S"
        //  *  [CONSTANT_NameAndType_info] for above
        //  *  [CONSTANT_Methodref_info] for above
        // ++  [UTF-8] "Field is final"
        // ++  [CONSTANT_String_info] for above
        // ++  [UTF-8] "java/lang/IllegalAccessException"
        // ++  [CONSTANT_Class_info] for above
        // ++  [CONSTANT_Methodref_info] for IllegalAccessException's constructor taking a String

        short numCPEntries = NUM_BASE_CPOOL_ENTRIES + NUM_COMMON_CPOOL_ENTRIES;
        if (isPrimitive(type)) {
            numCPEntries += NUM_BOXING_CPOOL_ENTRIES;
        } else {
            numCPEntries += NUM_NONPRIMITIVE_CPOOL_ENTRIES;
        }
        if (Modifier.isFinal(modifiers)) {
            numCPEntries += NUM_FINAL_FIELD_CPOOL_ENTRIES;
        }
        asm.emitShort(add(numCPEntries, S1));

        final String generatedName = generateName();
        asm.emitConstantPoolUTF8(generatedName);
        asm.emitConstantPoolClass(asm.cpi());
        thisClass = asm.cpi();
        asm.emitConstantPoolUTF8("sun/reflect/FieldAccessorImpl");
        asm.emitConstantPoolClass(asm.cpi());
        superClass = asm.cpi();
        asm.emitConstantPoolUTF8(getClassName(declaringClass, false));
        asm.emitConstantPoolClass(asm.cpi());
        targetClass = asm.cpi();
        asm.emitConstantPoolUTF8(name);
        asm.emitConstantPoolUTF8(getClassName(type, true));
        asm.emitConstantPoolNameAndType(sub(asm.cpi(), S1), asm.cpi());
        asm.emitConstantPoolFieldref(targetClass, asm.cpi());
        targetFieldRef = asm.cpi();
        if (!isPrimitive(type)) {
            asm.emitConstantPoolUTF8(getClassName(type, false));
            asm.emitConstantPoolClass(asm.cpi());
            targetFieldType = asm.cpi();
        }

        // Now emit the method names and descriptors
        asm.emitConstantPoolUTF8("get");
        getIdx = asm.cpi();
        asm.emitConstantPoolUTF8("(Ljava/lang/Object;)Ljava/lang/Object;");

        asm.emitConstantPoolUTF8("getBoolean");
        getBooleanIdx = asm.cpi();
        asm.emitConstantPoolUTF8("(Ljava/lang/Object;)Z");

        asm.emitConstantPoolUTF8("getByte");
        getByteIdx = asm.cpi();
        asm.emitConstantPoolUTF8("(Ljava/lang/Object;)B");

        asm.emitConstantPoolUTF8("getChar");
        getCharIdx = asm.cpi();
        asm.emitConstantPoolUTF8("(Ljava/lang/Object;)C");

        asm.emitConstantPoolUTF8("getShort");
        getShortIdx = asm.cpi();
        asm.emitConstantPoolUTF8("(Ljava/lang/Object;)S");

        asm.emitConstantPoolUTF8("getInt");
        getIntIdx = asm.cpi();
        asm.emitConstantPoolUTF8("(Ljava/lang/Object;)I");

        asm.emitConstantPoolUTF8("getLong");
        getLongIdx = asm.cpi();
        asm.emitConstantPoolUTF8("(Ljava/lang/Object;)J");

        asm.emitConstantPoolUTF8("getFloat");
        getFloatIdx = asm.cpi();
        asm.emitConstantPoolUTF8("(Ljava/lang/Object;)F");

        asm.emitConstantPoolUTF8("getDouble");
        getDoubleIdx = asm.cpi();
        asm.emitConstantPoolUTF8("(Ljava/lang/Object;)D");

        asm.emitConstantPoolUTF8("set");
        setIdx = asm.cpi();
        asm.emitConstantPoolUTF8("(Ljava/lang/Object;Ljava/lang/Object;)V");

        asm.emitConstantPoolUTF8("setBoolean");
        setBooleanIdx = asm.cpi();
        asm.emitConstantPoolUTF8("(Ljava/lang/Object;Z)V");

        asm.emitConstantPoolUTF8("setByte");
        setByteIdx = asm.cpi();
        asm.emitConstantPoolUTF8("(Ljava/lang/Object;B)V");

        asm.emitConstantPoolUTF8("setChar");
        setCharIdx = asm.cpi();
        asm.emitConstantPoolUTF8("(Ljava/lang/Object;C)V");

        asm.emitConstantPoolUTF8("setShort");
        setShortIdx = asm.cpi();
        asm.emitConstantPoolUTF8("(Ljava/lang/Object;S)V");

        asm.emitConstantPoolUTF8("setInt");
        setIntIdx = asm.cpi();
        asm.emitConstantPoolUTF8("(Ljava/lang/Object;I)V");

        asm.emitConstantPoolUTF8("setLong");
        setLongIdx = asm.cpi();
        asm.emitConstantPoolUTF8("(Ljava/lang/Object;J)V");

        asm.emitConstantPoolUTF8("setFloat");
        setFloatIdx = asm.cpi();
        asm.emitConstantPoolUTF8("(Ljava/lang/Object;F)V");

        asm.emitConstantPoolUTF8("setDouble");
        setDoubleIdx = asm.cpi();
        asm.emitConstantPoolUTF8("(Ljava/lang/Object;D)V");

        // Entries common to FieldAccessor and MethodAccessor
        emitCommonConstantPoolEntries();

        // Boxing entries
        if (isPrimitive(type)) {
            emitBoxingContantPoolEntries();
        }

        // Final field entries if necessary
        if (Modifier.isFinal(modifiers)) {
            asm.emitConstantPoolUTF8("Field is final");
            asm.emitConstantPoolString(asm.cpi());
            fieldIsFinalIdx = asm.cpi();
            asm.emitConstantPoolUTF8("java/lang/IllegalAccessException");
            asm.emitConstantPoolClass(asm.cpi());
            illegalAccessClass = asm.cpi();
            asm.emitConstantPoolMethodref(illegalAccessClass,
                                          initStringNameAndTypeIdx);
            illegalAccessStringCtorIdx = asm.cpi();
        }

        if (asm.cpi() != numCPEntries) {
            throw new InternalError("Adjust this code (cpi = " + asm.cpi() +
                                    ", numCPEntries = " + numCPEntries + ")");
        }

        // Access flags
        asm.emitShort(ACC_PUBLIC);

        // This class
        asm.emitShort(thisClass);
    
        // Superclass
        asm.emitShort(superClass);

        // Interfaces count and interfaces
        asm.emitShort(S0);
    
        // Fields count and fields
        asm.emitShort(S0);

        // Methods count and methods
        asm.emitShort(NUM_METHODS);
    
        emitConstructor();
        emitGet();
        emitGetBoolean();
        emitGetByte();
        emitGetChar();
        emitGetShort();
        emitGetInt();
        emitGetLong();
        emitGetFloat();
        emitGetDouble();

        if (!Modifier.isFinal(modifiers)) {
            emitSet();
            emitSetBoolean();
            emitSetByte();
            emitSetChar();
            emitSetShort();
            emitSetInt();
            emitSetLong();
            emitSetFloat();
            emitSetDouble();
        } else {
            emitThrowIllegalAccessForFinalField(setIdx,        false);
            emitThrowIllegalAccessForFinalField(setBooleanIdx, false);
            emitThrowIllegalAccessForFinalField(setByteIdx,    false);
            emitThrowIllegalAccessForFinalField(setCharIdx,    false);
            emitThrowIllegalAccessForFinalField(setShortIdx,   false);
            emitThrowIllegalAccessForFinalField(setIntIdx,     false);
            emitThrowIllegalAccessForFinalField(setLongIdx,    true);
            emitThrowIllegalAccessForFinalField(setFloatIdx,   false);
            emitThrowIllegalAccessForFinalField(setDoubleIdx,  true);
        }
    
        // Additional attributes (none)
        asm.emitShort(S0);

        // Load class
        vec.trim();
        final byte[] bytes = vec.getData();
        // Note: the class loader is the only thing that really matters
        // here -- it's important to get the generated code into the
        // same namespace as the target class. Since the generated code
        // is privileged anyway, the protection domain probably doesn't
        // matter.
        return (FieldAccessor)
            AccessController.doPrivileged(new PrivilegedAction() {
                    public Object run() {
                        try {
                            return ClassDefiner.defineClass
                                (generatedName,
                                 bytes,
                                 0,
                                 bytes.length,
                                 declaringClass.getClassLoader()).newInstance();
                        } catch (InstantiationException e) {
                            throw (InternalError)
                                new InternalError().initCause(e);
                        } catch (IllegalAccessException e) {
                            throw (InternalError)
                                new InternalError().initCause(e);
                        }
                    }
                });
    }

    private void emitGet()
    {
        // Generate code into fresh code buffer
        ClassFileAssembler cb = new ClassFileAssembler();
        // 1 incoming argument
        cb.setMaxLocals(2);

        if (isPrimitive(type)) {
            // new <boxing type for primitive type>
            // dup
            // if static:
            //   getstatic <target field name>
            // if nonstatic:
            //   aload_1
            //   checkcast <target class's type>
            //   getfield <target field name>
            // invokespecial <constructor for boxing type for primitive type>
            // areturn

            cb.opc_new(indexForPrimitiveType(type));
            cb.opc_dup();
            if (isStatic()) {
                cb.opc_getstatic(targetFieldRef, typeSizeInStackSlots(type));
            } else {
                cb.opc_aload_1();
                cb.opc_checkcast(targetClass);
                cb.opc_getfield(targetFieldRef, typeSizeInStackSlots(type));
            }
      
            cb.opc_invokespecial(ctorIndexForPrimitiveType(type),
                                 typeSizeInStackSlots(type),
                                 0);
        } else {
            // if static:
            //   getstatic <target field ref>
            // if nonstatic:
            //   aload_1
            //   checkcast <target class's type>
            //   getfield  <target field ref>
            // areturn

            if (isStatic()) {
                cb.opc_getstatic(targetFieldRef, 1);
            } else {
                cb.opc_aload_1();
                cb.opc_checkcast(targetClass);
                cb.opc_getfield(targetFieldRef, 1);
            }
        }

        cb.opc_areturn();
        short exceptionEndPC = cb.getLength();

        // Emit exception handler
        emitIllegalArgumentConversionExceptionHandler(cb);

        // Generate exception table. We cover the entire code sequence
        // with an exception handler which catches ClassCastException and
        // converts it into an IllegalArgumentException.

        ClassFileAssembler exc = new ClassFileAssembler();
        exc.emitShort(S0);                      // start PC
        exc.emitShort(exceptionEndPC);          // end PC
        exc.emitShort(exceptionEndPC);          // handler PC
        exc.emitShort(classCastClass);          // catch type

        // Emit method
        emitMethod(getIdx, cb.getMaxLocals(), cb, exc, null);
    }

    private void emitGetBoolean() { emitGetPrimitive(getBooleanIdx, Boolean.TYPE);   }
    private void emitGetByte()    { emitGetPrimitive(getByteIdx,    Byte.TYPE);      }
    private void emitGetChar()    { emitGetPrimitive(getCharIdx,    Character.TYPE); }
    private void emitGetShort()   { emitGetPrimitive(getShortIdx,   Short.TYPE);     }
    private void emitGetInt()     { emitGetPrimitive(getIntIdx,     Integer.TYPE);   }
    private void emitGetLong()    { emitGetPrimitive(getLongIdx,    Long.TYPE);      }
    private void emitGetFloat()   { emitGetPrimitive(getFloatIdx,   Float.TYPE);     }
    private void emitGetDouble()  { emitGetPrimitive(getDoubleIdx,  Double.TYPE);    }

    private void emitGetPrimitive(short methodNameIdx, Class destType)
    {
        ClassFileAssembler cb;
        ClassFileAssembler exc = null;
        if (!canWidenTo(type, destType)) {
            cb = illegalArgumentCodeBuffer();
        } else {
            // Generate code into fresh code buffer
            cb = new ClassFileAssembler();

            // Code pattern:
            // if static:
            //   getstatic <target field ref>
            // if nonstatic:
            //   aload_1
            //   checkcast <target class's type>
            //   getfield  <target field ref>
            // <widening conversion, if necessary>
            // [ildf]return

            if (isStatic()) {
                cb.opc_getstatic(targetFieldRef, typeSizeInStackSlots(type));
            } else {
                cb.opc_aload_1();
                cb.opc_checkcast(targetClass);
                cb.opc_getfield(targetFieldRef, typeSizeInStackSlots(type));
            }

            emitWideningBytecodeForPrimitiveConversion(cb, type, destType);
            emitReturnInstructionForPrimitiveType(cb, destType);

            short exceptionEndPC = cb.getLength();

            // Emit exception handler
            emitIllegalArgumentConversionExceptionHandler(cb);

            // Generate exception table. We cover the entire code sequence
            // with an exception handler which catches ClassCastException and
            // converts it into an IllegalArgumentException.

            exc = new ClassFileAssembler();
            exc.emitShort(S0);                      // start PC
            exc.emitShort(exceptionEndPC);          // end PC
            exc.emitShort(exceptionEndPC);          // handler PC
            exc.emitShort(classCastClass);          // catch type
        }

        emitMethod(methodNameIdx, 2, cb, exc, null);
    }

    private void emitSet()
    {
        // Generate code into fresh code buffer
        ClassFileAssembler cb = new ClassFileAssembler();
        // 2 incoming arguments
        cb.setMaxLocals(3);

        // if nonstatic:
        //   aload_1
        //   checkcast
        if (!isStatic()) {
            cb.opc_aload_1();
            cb.opc_checkcast(targetClass);
        }

        if (isPrimitive(type)) {
            // repeat for all possible widening conversions:
            //   aload_2
            //   instanceof <primitive boxing type>
            //   ifeq <next label>
            //   aload_2
            //   checkcast <primitive boxing type> // Note: this is "redundant",
            //                                     // but necessary for the verifier
            //   invokevirtual <unboxing method>
            //   <widening conversion bytecode, if necessary>
            //   if static:
            //     putstatic <target field ref>
            //   if nonstatic:
            //     putfield <target field ref>
            //   return
            // <next label:> ...
            // last label:
            //   new <IllegalArgumentException>
            //   dup
            //   invokespecial <IllegalArgumentException ctor>
            //   athrow

            Label l = null;

            for (int i = 0; i < primitiveTypes.length; i++) {
                Class c = primitiveTypes[i];
                if (canWidenTo(c, type)) {
                    if (l != null) {
                        l.bind();
                    }
                    // Emit checking and unboxing code for this type
                    cb.opc_aload_2();
                    cb.opc_instanceof(indexForPrimitiveType(c));
                    l = new Label();
                    cb.opc_ifeq(l);
                    cb.opc_aload_2();
                    cb.opc_checkcast(indexForPrimitiveType(c));
                    cb.opc_invokevirtual(unboxingMethodForPrimitiveType(c),
                                         0,
                                         typeSizeInStackSlots(c));
                    emitWideningBytecodeForPrimitiveConversion(cb, c, type);
                    if (isStatic()) {
                        cb.opc_putstatic(targetFieldRef,
                                         typeSizeInStackSlots(type));
                    } else {
                        cb.opc_putfield(targetFieldRef,
                                        typeSizeInStackSlots(type));
                    }
                    cb.opc_return();
                }
            }

            if (l == null) {
                throw new InternalError
                    ("Must have found at least identity conversion");
            }
      
            // Fell through; given object is null or invalid. According to
            // the spec, we can throw IllegalArgumentException for both of
            // these cases.

            l.bind();
            cb.opc_new(illegalArgumentClass);
            cb.opc_dup();
            cb.opc_invokespecial(illegalArgumentCtorIdx, 0, 0);
            cb.opc_athrow();
        } else {
            // aload_2
            // checkcast <target field's type>
            // if static:
            //   putstatic <target field ref>
            // if nonstatic:
            //   putfield <target field ref>

            cb.opc_aload_2();
            cb.opc_checkcast(targetFieldType);
            if (isStatic()) {
                cb.opc_putstatic(targetFieldRef, 1);
            } else {
                cb.opc_putfield(targetFieldRef, 1);
            }
            cb.opc_return();
        }

        // Emit exception handler code
        short exceptionEndPC = cb.getLength();

        // Emit exception handler
        emitIllegalArgumentConversionExceptionHandler(cb);

        // Generate exception table. We cover the entire code sequence
        // with an exception handler which catches ClassCastException and
        // converts it into an IllegalArgumentException.

        ClassFileAssembler exc = new ClassFileAssembler();
        exc.emitShort(S0);                      // start PC
        exc.emitShort(exceptionEndPC);          // end PC
        exc.emitShort(exceptionEndPC);          // handler PC
        exc.emitShort(classCastClass);          // catch type

        // Generate method
        emitMethod(setIdx, cb.getMaxLocals(), cb, exc, null);
    }

    private void emitSetBoolean() { emitSetPrimitive(setBooleanIdx, Boolean.TYPE);   }
    private void emitSetByte()    { emitSetPrimitive(setByteIdx,    Byte.TYPE);      }
    private void emitSetChar()    { emitSetPrimitive(setCharIdx,    Character.TYPE); }
    private void emitSetShort()   { emitSetPrimitive(setShortIdx,   Short.TYPE);     }
    private void emitSetInt()     { emitSetPrimitive(setIntIdx,     Integer.TYPE);   }
    private void emitSetLong()    { emitSetPrimitive(setLongIdx,    Long.TYPE);      }
    private void emitSetFloat()   { emitSetPrimitive(setFloatIdx,   Float.TYPE);     }
    private void emitSetDouble()  { emitSetPrimitive(setDoubleIdx,  Double.TYPE);    }

    private void emitSetPrimitive(short methodNameIdx, Class srcType)
    {
        ClassFileAssembler cb;
        ClassFileAssembler exc = null;
        if (!canWidenTo(srcType, type)) {
            cb = illegalArgumentCodeBuffer();
        } else {
            // Generate code into fresh code buffer
            cb = new ClassFileAssembler();
            // Code pattern:
            // if nonstatic:
            //   aload_1
            //   checkcast
            // [ildf]load_2
            // <widening conversion, if necessary>
            // if static:
            //   putstatic <target field ref>
            // if nonstatic:
            //   putfield <target field ref>
            // return

            if (!isStatic()) {
                cb.opc_aload_1();
                cb.opc_checkcast(targetClass);
            }
            emitLoad2ForPrimitiveType(cb, srcType);
            emitWideningBytecodeForPrimitiveConversion(cb, srcType, type);
            if (isStatic()) {
                cb.opc_putstatic(targetFieldRef, typeSizeInStackSlots(type));
            } else {
                cb.opc_putfield(targetFieldRef, typeSizeInStackSlots(type));
            }
            cb.opc_return();

            short exceptionEndPC = cb.getLength();

            // Emit exception handler
            emitIllegalArgumentConversionExceptionHandler(cb);

            // Generate exception table. We cover the entire code sequence
            // with an exception handler which catches ClassCastException and
            // converts it into an IllegalArgumentException.

            exc = new ClassFileAssembler();
            exc.emitShort(S0);                      // start PC
            exc.emitShort(exceptionEndPC);          // end PC
            exc.emitShort(exceptionEndPC);          // handler PC
            exc.emitShort(classCastClass);          // catch type
        }

        int maxLocals = 3;
        if (srcType == Long.TYPE || srcType == Double.TYPE) {
            maxLocals = 4;
        }

        emitMethod(methodNameIdx, maxLocals, cb, exc, null);
    }

    /** Emits a code buffer which throws IllegalAccessException("Field
        is final") as the body of the specified method (set() or one of
        the primitive variants). */
    private void emitThrowIllegalAccessForFinalField(short methodNameIdx,
                                                     boolean forDoubleOrLong)
    {
        ClassFileAssembler cb = new ClassFileAssembler();
        cb.opc_new(illegalAccessClass);
        cb.opc_dup();
        cb.opc_ldc((byte) fieldIsFinalIdx);
        cb.opc_invokespecial(illegalAccessStringCtorIdx, 1, 0);
        cb.opc_athrow();

        int numArgs = (forDoubleOrLong ? 4 : 3);

        emitMethod(methodNameIdx,
                   numArgs,
                   cb,
                   null,
                   new short[] { illegalAccessClass });
    }

    private static synchronized String generateName()
    {
        int num = ++symnum;
        return "sun/reflect/GeneratedFieldAccessor" + num;
    }

    /** Must only be called for primitive types */
    private void emitReturnInstructionForPrimitiveType(ClassFileAssembler cb,
                                                       Class destType)
    {
        if (   destType == Boolean.TYPE
               || destType == Byte.TYPE
               || destType == Character.TYPE
               || destType == Short.TYPE
               || destType == Integer.TYPE) {
            cb.opc_ireturn();
        } else if (destType == Long.TYPE) {
            cb.opc_lreturn();
        } else if (destType == Float.TYPE) {
            cb.opc_freturn();
        } else if (destType == Double.TYPE) {
            cb.opc_dreturn();
        } else {
            throw new InternalError("Illegal primitive type" + destType.getName());
        }
    }

    private void emitLoad2ForPrimitiveType(ClassFileAssembler cb,
                                           Class primType)
    {
        if (   primType == Boolean.TYPE
               || primType == Byte.TYPE
               || primType == Character.TYPE
               || primType == Short.TYPE
               || primType == Integer.TYPE) {
            cb.opc_iload_2();
        } else if (primType == Long.TYPE) {
            cb.opc_lload_2();
        } else if (primType == Float.TYPE) {
            cb.opc_fload_2();
        } else if (primType == Double.TYPE) {
            cb.opc_dload_2();
        } else {
            throw new InternalError("Illegal primitive type" + primType.getName());
        }
    }

    private void emitIllegalArgumentConversionExceptionHandler
        (ClassFileAssembler cb)
    {
        cb.setStack(1);
        cb.opc_invokevirtual(toStringIdx, 0, 1);
        cb.opc_new(illegalArgumentClass);
        cb.opc_dup_x1();
        cb.opc_swap();
        cb.opc_invokespecial(illegalArgumentStringCtorIdx, 1, 0);
        cb.opc_athrow();
    }
}
